# MeshCore Contact System: Architecture and Operation


 [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)

## 1. Contact Origin and Discovery

**How contacts are added:** MeshCore devices learn about peers through a **discovery broadcast** mechanism. Each node periodically (or on demand) sends a small *advertisement* packet containing its identity and metadata (name, node type, etc.) to the mesh network. Any MeshCore radio that receives this advert will recognize the presence of a new node. If the sender’s public key (identity) is not already known, the receiver creates a new contact entry for that node. This is the primary way contacts “initially get added” – by *hearing* another device on the air. In other words, **contacts are discovered automatically** via these mesh network adverts. However, whether they appear in your contact list immediately or not depends on settings (see **Manual vs Auto-Add** below). Alternatively, contacts can also be added manually *out-of-band*: for example, by scanning a QR code or sharing a contact URL that encodes a node’s name and public key. Scanning such a `meshcore://contact/add?...` link imports that contact directly without needing an over-the-air discovery. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md)

**Automatic vs Manual addition:** MeshCore supports both automatic contact population and manual management modes. In *auto-add* mode (the default on many devices), any discovered peer is immediately added to your contact list, up to the device’s storage limit. This means if your radio hears a new node’s advert (even over multi-hop via repeaters), it will create a stored contact for it automatically. Auto-add is convenient in small deployments, but in large networks it can quickly fill your contact list with hundreds of entries (including distant strangers). In *manual* mode, the device still discovers other nodes (keeps them in a temporary discovered list), but does **not** automatically promote them to full contacts without user action. The Home Assistant MeshCore integration, for example, forces manual mode: newly heard devices are marked “discovered” and require the user to explicitly confirm adding them. In this state, the entry is visible but inactive (no messaging) until approved. This gives you control to only add desired contacts. In summary, **contacts can populate either by automatic discovery or by manual confirmation**. Enabling auto-add yields a hands-off experience (all mesh neighbors become contacts), whereas disabling it lets you curate who ends up in your address book. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121) [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Relationship to LoRa mesh nodes:** In MeshCore, **each contact corresponds to another MeshCore node** on the network. The contact list is essentially the list of known peer devices (participants) in the mesh. There isn’t a separate concept of “contacts” vs “nodes” – they are one and the same, just viewed from your device’s perspective. For example, if there are 5 MeshCore radios in range (on the same network), each one will appear as a contact on the others. Contacts do *not* represent arbitrary LoRa nodes outside the MeshCore system – a device running a different protocol (like Meshtastic) will **not** be discovered or listed by MeshCore. Only MeshCore-enabled devices sharing compatible channel settings will exchange adverts and become contacts. By design, MeshCore adverts carry cryptographic identity info (see Section 5) that only MeshCore peers understand, so you won’t see non-MeshCore nodes in the contact list. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

**Do new devices automatically appear?** Generally, yes – if a new MeshCore device joins the mesh (and transmits an advert), other nodes will detect it and list it. On an open MeshCore network (no special pairing required), a new radio that comes online will eventually broadcast its presence. Nearby nodes that hear that broadcast will create a contact for it (either automatically adding or marking discovered). In practice, this might not be instantaneous; **MeshCore’s discovery is designed to be low-frequency and efficient**. Unlike some systems that frequently beacon, a MeshCore companion device might only broadcast an advert infrequently (perhaps on startup or every few hours) to conserve airtime. Dedicated repeaters do send periodic adverts (by default, on the order of every 4 hours) announcing network presence. But a handheld “companion” node often stays quiet unless prompted (the user can trigger an immediate “Advertise” command via the app). This means if two new devices come online near each other, they **may not instantly show up** in each other’s contacts until one of them sends an advert or traffic. In summary: new devices *will* appear on others automatically *once an advert is exchanged*, but MeshCore’s default behavior is to minimize chatter, so there may be a delay or a need to manually initiate discovery in some cases. Once that advert handshake occurs, the new node is recognized and added across the mesh (subject to auto/manual settings). [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery), [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

*Manual addition example:* If you don’t want to wait for the next periodic advert, you can explicitly share contacts. For instance, each MeshCore app can display a QR code for its node. Scanning this on another device imports the contact immediately. The QR encodes the contact’s name, public key, and type (e.g. `meshcore://contact/add?name=<Name>&public_key=<Key>&type=1` for a chat node). This out-of-band method is essentially the same information that would be learned via an over-the-air advert, but it’s done via a direct scan or link. It’s useful for quickly populating contacts in a controlled way (like at a meetup, exchanging contact info directly). [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md)

**Advertising and discovery summary:** Whenever a MeshCore radio **broadcasts an identity advert**, all others within radio range (direct or via repeater hops) will **discover** that node. Each receiving device will check if it already knows this identity; if not, it will create a new contact entry for the sender. Those new contacts either immediately appear or await user approval depending on configuration. Thus, contacts are primarily populated by the **mesh network activity itself**, rather than manual data entry (though manual sharing is available). This design keeps things simple for users – just turning on nodes in the same mesh network is usually enough for them to learn about each other. (Do note that if two devices are completely out of range and have no intermediary, they won’t know each other until a link is established somehow.) In a multi-hop mesh with repeaters, a new device’s advert can propagate through the repeaters, causing even far-away nodes to add that device as a contact (this is how large-scale networks can lead to very extensive contact lists). If that’s undesirable, users can limit auto-add or restrict by hop count (a feature request suggests adding an auto-add hop limit to avoid very distant nodes being added). In any case, the **act of joining the mesh (by being on the same frequency/channel and exchanging adverts) is what causes devices to appear as contacts** on each other. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546)


 [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Contacts vs nodes vs channels:** It’s important to note that MeshCore networks can be segmented by “channel” configurations (similar to how Meshtastic works). If all devices use the same base channel (e.g. default frequency and no encryption), they will hear each other’s adverts and become contacts. But if a device is on a different channel (different frequency or encryption secret), it won’t hear the adverts – effectively making it invisible. Thus, contacts only appear among nodes that share compatible channel settings. Many public MeshCore users operate on a common open channel (so they all see each other), whereas a private team might use a unique channel secret to restrict discovery to their group. This channel mechanism is separate from the contact list itself but influences which contacts you’ll have (more in Security/Privacy section). By default, the main “All” channel in MeshCore is an open broadcast domain. Devices on that default channel will opportunistically discover any MeshCore node nearby on the same frequency. If you configure a custom secure channel, you will only discover nodes that also have that secret – providing privacy and limiting contacts to your intended set. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

**Key takeaways:** Contacts originate from **other MeshCore radios** announcing themselves. Discovery can be **automatic** and wide-ranging (every node you hear becomes a contact), or **controlled** (you choose who to add). Each contact entry fundamentally represents one MeshCore-enabled device/node in the LoRa mesh. New devices will show up on others after an initial handshake (advert exchange). The system is decentralized – there’s no central server pushing contacts; it’s all driven by peer-to-peer radio broadcasts and local storage. This allows MeshCore to scale in off-grid environments, but it also means that in a busy mesh you may accumulate a lot of contacts (we’ll discuss management strategies in Section 8).

## 2. Contact Data Structure and Storage

**What data does a contact contain?** Each contact entry in MeshCore is a structured record holding all information needed to identify the peer and communicate with it. At a high level, a contact includes:

*   **Identity (Node ID):** The peer’s unique cryptographic identifier, specifically its Ed25519 **public key** (32 bytes). This key essentially serves as the “NodeID” of the contact – it’s the fundamental identifier for that device. For convenience, a shortened hash of the public key is used in some contexts as an address or index (e.g. a 4-byte or 7-byte prefix of the SHA-256 of the public key). This is how MeshCore can have a compact “address” for routing while still tying it back to a full public key for security. In effect, **NodeIDs are derived from each device’s public key** – providing a verifiable device identifier. (No two nodes should share the same public key; if they did, it would be a collision – an extremely unlikely event when keys are generated with proper entropy. In fact, a bug in early firmware once caused duplicate keys, which led to contact confusion, but under normal operation keys are unique.) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   **Name:** a human-readable nickname for the node (up to 31 characters). This is the name the user assigns to their device, broadcast in adverts. The contact record stores the latest known name for that peer. If the user of that peer changes the device’s name, your device will update the stored name on the next received advert from it. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   **Type:** the node’s role/type code. MeshCore categorizes nodes by function: for example, `1 = chat (regular user device)`, `2 = repeater`, `3 = room server`, `4 = sensor`. The contact entry has a field to denote this, so the system/UIs know what kind of device it is. (E.g. a repeater might be shown with a different icon and not listed in messaging menus, whereas a “chat” contact is a person you can message.) [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)
*   **Flags:** bitflags for various settings or status on that contact. Currently this includes things like a “favorite” marker (to pin important contacts), and possibly permission bits (for future use, e.g. to indicate if this contact is allowed certain accesses). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)
*   **Last seen timestamp:** the time (according to the contact’s own last advertised time or combined logic) when this contact last transmitted an advertisement. This is used to determine Fresh vs Stale status (Section 3). The record stores the peer’s last advert timestamp (which is the time from the peer’s device, in their clock) as well as a local timestamp of when we last updated the contact. Essentially, it provides a record of when the contact was last active on the mesh. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)
*   **Routing path info:** MeshCore can store a known **outbound path** to reach the contact, if one has been learned. The “out\_path” field can hold a sequence of intermediate node hashes for a multi-hop route to that contact (up to 64 bytes, which can represent several hops). If the contact is directly reachable, this might be blank/unused. If the network learned that, say, to reach contact X you should go via repeater Y, then X’s contact entry on your device will note that route. The path info helps optimize sending messages (so the device doesn’t always flood if it knows a specific next hop). There’s also an `out_path_len` indicating how many hops are in the stored route. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)
*   **Shared secret:** a 32-byte secret key that your device has computed for this contact using ECDH (Elliptic Curve Diffie-Hellman). This is essentially a one-to-one encryption key between you and that peer, derived from combining your private key and the contact’s public key. It’s stored in the contact record so that the device can encrypt/decrypt messages to/from that peer quickly without redoing the math each time. (More on encryption in section 5, but in short: **this is how MeshCore achieves secure messaging per contact**.) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)
*   **GPS coordinates (optional):** If the peer device shares its location, the contact entry can store the last known latitude/longitude of that contact. MeshCore devices can include their GPS coordinates in advertisements (for example, a teammate’s radio might broadcast their position periodically). Those coordinates (in micro-degrees) get recorded in the contact structure. This is useful for mapping features or search-and-rescue scenarios. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)
*   **Sync marker:** a timestamp used for message synchronization purposes. This is primarily used with Room Server contacts (type 3) to mark until when you’ve received messages. For a regular contact, this field might remain at default. In a room server context, it tracks the last message timestamp you’ve seen so the server knows what history to send (see section 6). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

To summarize, a contact entry contains **identifiers (who it is), context (name/type), status (last seen, flags), and communication parameters (shared crypto key, route info, etc.)**. The design goal is that the contact record has everything needed to address and encrypt a packet to that peer. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

<table>
<tr><th>Field</th><th>Description</th></tr>
<tr><td><code>Public Key</code></td><td>Ed25519 32-byte identity for the contact (unique node identifier)</td></tr>
<tr><td><code>Name</code></td><td>Null-terminated string (up to 31 chars) with the contact’s display name</td></tr>
<tr><td><code>Type</code></td><td>Node type code (1=chat client, 2=repeater, 3=room server, 4=sensor, etc.)</td></tr>
<tr><td><code>Flags</code></td><td>Status/permission flags (e.g. favorite, blocked, etc. – LSB is “favorite”)</td></tr>
<tr><td><code>Last Advert</code></td><td>Timestamp of last advertisement heard from this contact (as reported by that node’s own clock)</td></tr>
<tr><td><code>OutPath</code></td><td>Stored routing path (sequence of hop identifiers) to reach this contact, if known (64 bytes max)</td></tr>
<tr><td><code>Shared Secret</code></td><td>32-byte ECDH-derived secret key for encrypting traffic with this contact</td></tr>
<tr><td><code>Last Modified</code></td><td>Local timestamp when this contact entry was last updated in our device</td></tr>
<tr><td><code>GPS Lat/Lon</code></td><td>Last reported latitude/longitude of this contact (if any), as 32-bit ints (1e-6 deg)</td></tr>
<tr><td><code>Sync Since</code></td><td>Synchronization marker (e.g. last message timestamp synced) – mainly for room server usage</td></tr>
</table>

Each of these fields corresponds to members in the `ContactInfo` structure in MeshCore’s firmware code. For instance, the code defines something like: `char name[32]; uint8_t type; uint8_t flags; int8_t out_path_len; uint8_t out_path[64]; uint32_t last_advert_timestamp; uint8_t shared_secret[32]; uint32_t lastmod; int32_t gps_lat, gps_lon; uint32_t sync_since; Identity id;`. The `Identity id` in turn contains the `pub_key[32]` and maybe a short hash for quick comparisons. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**NodeID generation:** The **Node ID** concept in MeshCore is essentially tied to the device’s public key. There isn’t an arbitrary numeric ID that gets assigned; instead, the public key (or a hash of it) *is* the identity. MeshCore derives a node’s “address” by hashing its public key (SHA-256) and using a portion of that hash as a short address. This means any node’s short ID is cryptographically linked to its long identity key. In practical terms, if you see an identifier like `0xA1B2C3D4` in logs or routing tables, that’s likely the first 4 bytes of the SHA-256 of someone’s Ed25519 public key. This approach ensures that *address collisions are extremely unlikely* (and if two were to collide on short address, the full 32-byte key would still differentiate them). It also prevents spoofing because a malicious node can’t choose a short ID arbitrarily – it only gets whatever hash its actual key produces. (The MeshCore documentation notes this “cryptographically verifiable addressing scheme” where node addresses derive from public key hashes.) In summary, **each contact’s NodeID is effectively its public key (or its hash)**. The public key is stored in full in the contact record and is the ultimate identifier, and from that the system computes any shorter addresses needed for routing. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

**Storage location:** Contacts are stored \*\*persistently on the device’s flash# MeshCore Contact System: Fundamental Overview

 [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference), [\[localmesh.nl\]](https://www.localmesh.nl/en/meshcore-network-troubleshooting/), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

MeshCore’s **contact system** is the way each device recognizes and keeps track of other nodes in the LoRa mesh network. A “contact” in MeshCore essentially represents another MeshCore radio/node that your device is aware of, including the information needed for secure communication with that node. Below, we break down the contact system’s behavior and design fundamentals: [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

## 1. Contact Origin and Population

**How contacts get added:** MeshCore nodes discover each other through periodic *advertisement broadcasts*. These adverts are short, unencrypted beacon packets that include the device’s identity (public key), chosen name, node type, and other metadata. Whenever your device **hears an advertisement** from a new node, it will recognize a new contact. This process is **automatic** – the firmware listens on the mesh channel for any incoming adverts (or other packets) and will create a contact entry for the sender if one doesn’t already exist. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Active vs passive discovery:** By design, MeshCore keeps network chatter low. Regular user devices (often called *companions*) do *not* constantly broadcast their presence at short intervals the way some other mesh systems do. In fact, a companion device might only send an initial advert on startup and then stay quiet, whereas dedicated **repeaters** are configured to send a “flood advert” infrequently (by default on the order of every few hours) to announce the network's presence more broadly. This means **contacts might not immediately show up** unless an advert is triggered. Users often manually trigger an advert (via the app or a CLI command like `advert`) to speed up discovery when setting up devices. Once one node broadcasts, any node in radio range (directly or via a repeater) will catch that advert and add the sender as a discovered contact. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference) [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

**Automatic vs manual addition:** Simply discovering a device doesn’t always mean it’s fully added to your contact list for communication. MeshCore supports both **auto-add** and **manual add** modes:

*   In **auto-add mode**, every new node your device hears will be automatically added to your contact list. This is convenient, but in a busy mesh it can quickly fill your contact list with distant strangers. In wide-area community meshes (like in the Netherlands, which now has a country-wide MeshCore network), users found that leaving auto-add on would populate their radio with “loads of people up north” far beyond their immediate needs. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546)
*   In **manual mode**, new nodes are kept in a **“discovered” list** but not fully added until you approve them. The MeshCore mobile app and integrations like Home Assistant use manual mode by default to give you control. In this state, the discovered contact is noted in memory (and even persisted separately so it’s not forgotten), but your device **won’t accept messages from or send to that node until you explicitly add it**. You might, for example, see a list of “Discovered devices” and choose which to add as contacts. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/) [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

This design means **contacts can originate in two ways**:

1.  **Heard on-air:** Most commonly, by hearing an on-air advertisement. E.g., if a new MeshCore radio comes within range (direct or via repeaters) and broadcasts its presence, your device will detect it and record it as a contact automatically (at least in discovered state). In a connected mesh, these adverts can propagate multiple hops, so even nodes not directly neighboring you might appear in your discovered list if repeaters relay their adverts. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)
2.  **Out-of-band sharing:** Alternatively, contacts can be added by sharing credentials directly (like scanning a QR code or using a URL containing the contact info). MeshCore supports exporting a contact’s info as a QR code or string (`meshcore://contact/add?...`) which encodes that node’s public key, name, and type. Scanning such a QR will import that contact as if you heard an advert. This is useful when radios are not currently in range or to ensure a trusted exchange of identity (for example, exchanging contact QRs at a meetup to be sure you have each other added). [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Relationship to mesh nodes:** In MeshCore, **each contact corresponds to a unique MeshCore node** on the LoRa mesh. Contacts are essentially an entry in your device’s “address book” for the mesh network. They do *not* represent arbitrary LoRa nodes outside the MeshCore system – only devices running MeshCore protocol will send recognizable adverts that become contacts. (MeshCore isn’t compatible with other LoRa mesh systems like Meshtastic, so those devices won’t appear in contacts.) Within MeshCore, contacts can be any node role – a handheld/user node, a fixed repeater, a room server, or even a sensor node. The **node’s type** is indicated in the contact info (more on this below), so your device knows, for example, that “Node X” is a repeater vs. a regular chat peer. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md)

**Do new devices automatically appear?** – Yes, if they broadcast an advert and your device is listening on the same channel settings, they will appear (at least as discovered). In a typical scenario, when you turn on two new MeshCore radios, you may need to manually trigger an advert on one or both to initiate the exchange. Once that happens, each will see the other as a new contact. After an initial handshake (each side learning the other’s info), they’re added to each other’s contact list. If auto-add is enabled, this might all happen in the background; if not, you’d get a notification of a discovered node and then choose to “Add” it via the app.

Notably, the advertisement exchange is essentially a **cryptographic handshake**: each device learns the other’s public key and name. For full two-way communication, **both nodes need to have exchanged adverts**. If only one side advertised, the link is half-formed (one device knows about the other, but not vice versa). That’s why in practice it’s recommended that each new device either advertises or is added via QR to ensure both sides have each other’s info. After that, they will periodically re-advertise (or send keep-alive messages) so that their presence is known and their status stays “fresh.” [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

In summary, **contacts originate automatically from hearing mesh activity**, but whether they populate your usable contact list immediately or sit in a discovered pool depends on your settings. MeshCore leans toward *opt-in discovery* – your device stays quiet and doesn’t clutter itself with contacts until needed, which improves efficiency at the cost of a little more manual step for initial discovery. Power users in large networks often disable auto-add and manually curate contacts to avoid hitting device limits. On the other hand, in small deployments you might enable auto-add so that everyone on the mesh quickly shows up in everyone else’s list without intervention. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

## 2. Contact Data Structure and Storage

Each contact entry holds all the necessary information for your node to identify and communicate with that peer. Internally, MeshCore represents a contact with a struct called `ContactInfo`. The key fields included are: [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

| **Field**                                      | **Type & Size**                 | **Purpose**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| ---------------------------------------------- | ------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| **Public Identity** (`id`)                     | Ed25519 public key (32 bytes)   | **Node’s unique identity** in the mesh. This is effectively the node’s “address.” It’s a 256-bit public key used for encryption handshakes and as a unique identifier [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). All other fields are associated with this. MeshCore also derives a shorter NodeID from this (e.g. a hash/prefix) for routing efficiency [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl).                                                                                                                                                                                                                                                                                                                                                     |
| **Name**                                       | UTF-8 string (up to 32 chars)   | **Human-readable name** of the node [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), as advertised by that node. This is like the contact’s nickname (e.g. “Alice’s Radio”). It can be changed by the remote user; your device will update the stored name whenever it receives an advert with a new name from that same pubkey.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **Type**                                       | 1 byte code                     | **Node type or role** [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) – e.g. chat client, repeater, room server, sensor. This is indicated in the adverts. For example: `1` = standard end-user device (“chat”), `2` = repeater, `3` = room server, `4` = sensor [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md). Knowing the type can let the UI show an icon or handle the node differently (e.g. not expecting text messages from a sensor).                                                                                                                                                                                                                                                                                                                                |
| **Flags**                                      | 1 byte bitfield                 | **Contact flags** for permissions or preferences [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). Currently one bit is used to mark a “favorite” contact (for UI sorting). Other bits could represent permission levels (for future use, e.g. an admin flag or blocked flag).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              |
| **Last Advert Time** (`last_advert_timestamp`) | 4 bytes (Unix time)             | **Last seen timestamp** for this contact [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). This is the time (according to the remote node’s own clock) of the last advertisement your device received from them. It’s used to determine the contact’s freshness (and possibly to gauge clock skew between nodes).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |
| **Routing Path** (`out_path` + `out_path_len`) | up to 64 bytes stored           | **Known route to the contact** [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). MeshCore can store a learned multi-hop path (sequence of hashed node addresses) to reach this contact. If a direct link isn’t available, the mesh might learn that, say, Contact A is reachable via repeater B → repeater C. This field encodes such a route so your device can send messages via that path without flooding. If no specific path is known (`out_path_len = -1`), the mesh will resort to flooding or other routing strategies.                                                                                                                                                                                                                                                                                                            |
| **Shared Secret** (`shared_secret`)            | 32 bytes (AES key)              | **Encryption key for this contact** [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). This is the symmetric key derived via Elliptic Curve Diffie–Hellman (ECDH) between your device’s private key and the contact’s public key. It’s computed once upon first discovery and saved. All **end-to-end encrypted messages** between you and this contact use this 256-bit secret for AES encryption, ensuring confidentiality. Caching it avoids redoing the math each time [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl). (If the contact is a room server or other special node, this might be unused or used differently, since room messages can use channel keys.) |
| **GPS Coordinates** (`gps_lat`, `gps_lon`)     | 8 bytes total (two 32-bit ints) | **Last reported location** of this contact, if available [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). MeshCore can transmit GPS coordinates in adverts (for devices that have GPS or a set location). They are stored as lat/long in microdegrees. This is optional and may be 0 if not used. For mobile contacts it updates when they advertise new coordinates.                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |
| **Last Modified** (`lastmod`)                  | 4 bytes (Unix time)             | **Last update time (local)** – timestamp (on your device’s clock) when this contact entry was last changed [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage). For instance, if a contact’s name changed or a new advert was processed, `lastmod` is set to “now.” This can be used for syncing or to know how recent your info is relative to your own time.                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| **Sync Since** (`sync_since`)                  | 4 bytes (Unix time)             | **Sync marker for message history**, used primarily for room server contacts [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management). For a room server, this tracks up to what timestamp you have synced messages. It helps retrieve only new messages when you reconnect. For normal contacts this field isn’t used (often set to 0 or -1).                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      |

The combination of these fields means each contact entry is about \~**150 bytes** in size. In fact, the on-device storage format (`/contacts3` file) allocates a fixed 152 bytes per contact. This includes some padding and reserved bytes for alignment or future use. The **public key (identity)** and **name** take up the bulk of the space (32 bytes each), followed by the type, flags, path info, timestamps, etc. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Node IDs and identity:** It’s worth noting that MeshCore uses the contact’s Ed25519 public key as the fundamental identifier – this is essentially the node’s “true ID.” For practical addressing and lookup, the system often uses a shorter **NodeID derived from the public key**, such as a truncated hash. For example, the first 4 bytes of the SHA-256 of the public key may serve as a short address or index. The **protocol’s routing headers use hashed addresses** rather than the full 32-byte key for efficiency, but those hashes are globally unique with high probability and map back to the full key. This means when your device sees an incoming packet with a source or destination ID, it can match it to a contact via those stored prefixes. It also means an attacker can’t pick an arbitrary address – it has to correspond to some public key, providing a form of verification. In summary, **NodeIDs are cryptographic device identifiers derived from the node’s public key**, not random user-chosen numbers. They represent the same thing as the public key (the MeshCore identity), just in a compressed form. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

**Where contacts are stored:** MeshCore devices store contacts in **non-volatile memory** so that the list persists across reboots or power loss. On typical hardware (e.g. nRF52840-based devices or ESP32-based devices), there is an on-board flash filesystem (like SPIFFS or LittleFS). The contact database is kept in a file, commonly named `/contacts3`, on that filesystem. Each contact entry is stored as a fixed-size record in that file. When the device boots up, it **loads the contact list from flash into RAM** (into an array of ContactInfo structures) for fast access during operation. The firmware uses a **“DataStore”** abstraction to read/write this file, with a lazy-write mechanism to avoid excessive flash wear (it batches updates and writes them a few seconds after changes instead of every single time immediately). [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Capacity and limits:** Out of the box, the contact list can hold on the order of a few hundred contacts. Originally the firmware set a **limit of 300 contacts**, which some power users bumped up to 350; currently \~**350 entries** is a typical compiled limit for companion devices. This limit is somewhat arbitrary and is chosen based on memory/flash constraints. Every contact stored uses \~150 bytes of flash and is also loaded into RAM (which uses even more memory overhead as actual objects). Devices with more flash and RAM (like a Heltec T-Deck V4) have been tested with up to \~1000 contacts in memory, but that “does not run well” due to RAM usage and possibly CPU overhead. Smaller devices (like Seeed T1000 or RAK WisTag which have limited storage) might max out around 300-400 before running out of space. In fact, one user noticed errors beyond \~450 contacts on a device with limited flash. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

The **300-350 contact limit** is therefore a practical ceiling to prevent exhausting resources. It can be raised in custom builds (and some users with lots of neighbors have done so), but beyond a certain point performance degrades and unusual bugs can appear (e.g. one user reported their contact list UI misbehaving around 299 contacts due to an indexing bug). The mobile app also mirrors this limit – because the radio firmware is the “source of truth” for contact info, the app only knows about contacts the firmware has stored. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Storage consumption:** Each contact \~152 bytes means, for example, 200 contacts would consume \~30 KB in the flash file, and the maximum \~350 contacts would be \~53 KB. This is modest, but consider the device may also store other things (channel settings, message queue, logs, etc). The DataStore’s lazy-write (5 second delay) helps ensure that if many contacts are discovered in a short time (say you turn on a node and suddenly hear 50 new nodes), the device batches the flash writes rather than writing 50 times – this protects flash longevity. The contact file is preallocated to the maximum size (to avoid fragmentation), so even if you have fewer contacts, the file might always reserve space for the full 300+ entries. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Example:** If your device has say 10 contacts added, it will have 10 filled records in the contacts file and the rest are empty records. Those empty slots can be filled as you discover/add more peers until the max is reached. The device keeps an internal count of how many contacts are in use. When one is removed, its slot can be reused by a new contact later.

In addition to the contact list, MeshCore may maintain a small separate list for **“discovered but not added” contacts**. The Home Assistant integration documentation mentions `_discovered_contacts` being persisted in a `.storage` directory on the host system. On the device side, newly heard contacts are likely immediately stored in the main contacts file (either flagged as “not added” or just kept in memory until added – based on manual mode). There is also an **“advertisement blob” cache** file (`/adv_blobs`) which can hold raw advertisement packets for a number of recently seen nodes (up to 20 on internal flash, or 100 if an external QSPI flash is present). This is used by the system for things like re-broadcasting or processing full advert details that might not fit entirely in the contact struct (advert packets can be \~120 bytes). But the main point is that **contact info is stored locally on each device** in persistent memory. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

In summary, **each contact record contains** the node’s identity (public key), human name, node role, cryptographic keys for secure messaging, and some metadata like last seen time and route info. These records are saved to flash (file `/contacts3`) and loaded into RAM at runtime. The system is optimized for around a few hundred contacts per device; if you approach the limit, you may need to prune contacts or compile custom firmware to allow more. The structure is fixed-size and indexed by identity, making lookups by node ID or public key straightforward (the firmware has functions to search contacts by pubkey or by prefix). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)


## 3. Contact Lifecycle Management

**Persistence:** Once a contact is added to your MeshCore device, it remains stored indefinitely **until you remove it or wipe the device**. Contacts do not automatically expire or get deleted due to inactivity. In other words, your contact list is non-volatile and cumulative – it will keep growing as you encounter new nodes (up to the device’s limit). This is why some users who roam into large networks find their contact list filling up over time. Even if a particular contact hasn’t been seen on the air for weeks or months, it will still be present in your list (likely marked “stale,” see below) until you decide to prune it. The only automated removal that might happen is if you reset the whole device or intentionally format its storage (which erases all contacts at once). Otherwise, **contacts persist across reboots and long idle periods**. The Home Assistant docs explicitly note that even “discovered” contacts (not yet added) are persisted across restarts, so the system remembers whom it saw even if you haven’t added them. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

**Contact states (presence):** MeshCore provides simple status indicators for contacts based on recent activity:

*   **Discovered** – The contact has been seen on the mesh (your device received an advert from them) but you have **not added them** to your contact list yet (manual mode). In apps, these might appear in a “Discovered” section. You **cannot exchange messages** with a merely discovered contact; it’s one-way awareness. The device does keep track of them (so if you reboot, it still knows they were discovered), but until promotion to full contact, the firmware will ignore direct messages from them and not allow sending to them. They essentially live in a limbo state. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   **Fresh** – The contact is *added to your list* and has been active recently. “Fresh” typically means the contact’s last advertisement was within the last 12 hours. This implies the node is likely powered on and in range (or at least was earlier that day). Fresh contacts are considered *online* for practical purposes. You can send them messages and expect delivery. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)
*   **Stale** – The contact is added in your list but **has not been heard from in over 12 hours**. After 12h of radio silence from that node, the state flips to stale. Stale is basically an “offline” indicator – the device might be off, or out of range, or simply hasn’t had reason to transmit recently. You can still attempt to send messages to a stale contact (nothing stops you), but there’s a good chance they won’t receive it until they come back online (if at all). The stale threshold in MeshCore is 12 hours by default, but conceptually it’s just “not recently seen.” If that node later broadcasts again, your device will update the status back to fresh. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

These states are maintained automatically by the firmware using the `last_advert_timestamp` for each contact. The mobile app/UI will show a contact’s state (for example, with colored icons or labels like “stale”). Internally, a contact state change from fresh to stale is triggered by a simple time comparison (current time vs. last seen). There is **no active “pinging”** or explicit offline message; it’s passive based on not hearing adverts for a while.

 [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

Importantly, **MeshCore does not automatically delete stale contacts**. Going “stale” is just a status flag. The contact stays in your list (with state=`stale`) potentially forever, unless you choose to remove it. There is currently no firmware feature like “purge contacts not seen in 30 days” – although community members have discussed that idea as a future improvement (e.g., auto-purging long-unseen contacts unless marked favorite). As of now, housekeeping is manual. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Manual removal:** You can remove a contact via the app or CLI if you no longer need it. For example, in the mobile app’s contact settings you might swipe-to-delete or use a “Remove” button. Removing a contact frees up its slot for new contacts. If that same node is later heard again, it would show up as a new discovered contact (since you’d have no record of it after removal).

**Auto-add and removal interplay:** In auto-add mode, the device might add everyone it hears until the contact list is full, at which point it simply can’t add more (new ones might be ignored or overwrite something only if specifically coded, but by default it hits the limit). MeshCore does not implement an LRU rotation or automatic removal when full; it relies on the user to manage the list if it hits capacity. Some experienced users actually request that auto-add be turned *off* by default, precisely to avoid this issue of an ever-growing list consuming the device’s slots. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Synchronization across nodes:** There is *no cloud or over-the-air synchronization of contact lists between different devices you own*. Each MeshCore device builds its own contact list independently through discovery. For example, if you have two MeshCore radios (say a personal handheld and a base station), each will have its own list of contacts it has heard. There’s no built-in mechanism that makes your base station automatically share its contacts with your handheld or vice-versa. That said, because all devices are listening to the mesh, **the network itself propagates contact information** – e.g. if your base station hears a new node and your handheld is nearby on the same network, chances are your handheld will also hear that node’s advert (either directly or forwarded by the base station if it’s a repeater). In that way, eventually both devices might learn about all nodes in the mesh. But this is a function of both being on the mesh, not an explicit sync feature.

If you want to **transfer or backup contacts between devices**, you would use the **export/import** feature. MeshCore allows exporting a contact (basically retrieving its advert data) and then importing it on another device as if it was discovered. This can be done via QR codes or via the CLI. For instance, you could export your whole contact list by individually generating QR codes for each contact (tedious for many entries), or by directly copying the `/contacts3` file from one device to another (if you have access to the filesystem via a computer – this is not a standard user action, but it’s possible technically). The mobile app doesn’t yet have a one-click “sync contacts to another device” feature, but the idea of a unified contacts database that can be imported/exported easily has been floated. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Contact synchronization across the mesh:** This can also refer to how consistently a given contact’s info is propagated to everyone. The mesh does *not* guarantee that every node knows about every other node. It’s not a fully flooded directory (especially since adverts are infrequent). However, in practice, on an active mesh with repeaters, eventually most nodes become aware of most others, unless partitions exist. For example, if a new node joins and sends out a flood advert (which repeaters rebroadcast network-wide), all nodes within a few hops should discover it. On the other hand, if two groups are only occasionally connected by a transient link, their devices might not all know about each other. MeshCore’s philosophy is a bit more “need-to-know” – your radio doesn’t waste effort tracking far-off nodes you’ve never directly encountered unless the infrastructure specifically forwards those adverts to you.

That’s why advanced users in very large meshes propose features like hop-limited auto-add – e.g., “only auto-add contacts within 2 hops of me” to avoid your device listing hundreds of far-away nodes. Currently, without such a filter, if the network is fully connected (via repeaters), a node that leaves auto-add on *will* accumulate everyone’s contact. So **in a dense network, periodic sync is effectively happening via ads** (to the point that it can overwhelm device limits). In a sparse or deliberate network, you might only ever see a handful of contacts. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546)

**Contact lifecycle example:** Suppose you add a friend’s device as a contact today. You both communicate, and you see them as “Fresh” (last seen just now). If that friend then turns off their device for a day, on your device their contact will eventually show “Stale” (after 12h of no signal). Their entry is still there. A week later, you power on your device and the friend is still offline – their contact remains stale in your list. If you decide you don’t need them on this device (maybe it’s a loaner radio), you can delete the contact. If you don’t delete it, it will sit there indefinitely; perhaps months later you meet again and turn on the radios, and the moment your friend’s radio advertises, your device will recognize the public key, match it to the existing entry, update the name if needed, mark them Fresh again, and you’re back in business. All that time, the contact was saved even though inactive.

**Backing up contacts / device reset:** Before a firmware update or device reset, you might want to back up your contacts. As mentioned, you could export them via QR or use a tool (the MeshCore CLI or Python API) to retrieve the contact list. If you perform a **factory reset (format)** on a MeshCore device (`erase` command or a special button sequence), it will wipe the contact file and you’ll have to re-discover or re-import contacts afresh. Also note: if a device’s **own identity changes** (e.g., you intentionally or inadvertently generate a new keypair by wiping its identity), *other devices* will see it as a brand new device. They won’t tie it to the old identity. In practice, if you upgrade firmware but keep the same identity file, your contacts remain valid. But if something like the MeshOS 1.08 entropy bug happened (where many devices ended up with identical keys by accident), the recommendation was to erase and generate a new identity – doing so means others have to add your new identity as a separate contact. Always consider that **identity = contact**; a changed identity is a different contact as far as everyone is concerned. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)

**Synchronization of contact status:** When a contact goes from Fresh to Stale, that info isn’t actively broadcast; it’s just something your device notes. If that contact comes online again and sends an advert, everyone will individually mark it Fresh again.

**Contact list management across devices:** If you personally use multiple MeshCore devices (say a handheld and a base at home), you might want them to have the same set of contacts. Currently you’d manage that by either having both present to hear the same adverts or by manually adding contacts on both. There is no automatic personal syncing feature yet.

**Bottom line:** Contacts stick around until you do something about them. MeshCore gives you the tools (delete, export) but doesn’t automatically groom your list. It’s wise in large networks to occasionally prune contacts you don’t need to free space or mark key contacts as favorites if a future auto-purge feature ever gets implemented. Also, use manual mode if you want to limit who actually enters your list, letting others linger as “discovered” only. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

## 4. Network Discovery and Contact Resolution

**Discovery protocol:** MeshCore handles contact discovery using the advertisement mechanism discussed. The **“advert” is a specific packet type** (denoted as `PAYLOAD_TYPE_ADVERT`) in the MeshCore protocol. It contains the node’s public key, a short hash of it (for addressing), the node’s name, type, and possibly other info like firmware version or location. These adverts are **broadcast at the link layer** – meaning they are sent to no particular destination (almost like a radio beacon) over LoRa. On receiving an advert, a MeshCore node does the following: [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

1.  **Extract identity and metadata:** It reads the advert packet, pulling out the sender’s public key, name, type, etc.. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)
2.  **Check if already known:** It compares the public key (or its hash) against its existing contact list. If a contact with that identity already exists, it will simply update the stored info (e.g., refresh last seen time, update name if it changed, update GPS data). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
3.  **If unknown, create new contact:** If the identity is not found in the list, the firmware will allocate a new contact entry (if there is space) and store all the info as a *discovered* contact. By default it also immediately computes the shared secret for that identity (performing an ECDH key exchange using your private key and the received pubkey). This arms the device to communicate securely with the new contact going forward. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)
4.  **Notify application:** The system then notifies the higher-level application (e.g., the companion app or any listeners in firmware) that a **new contact was discovered**. This might result in a UI update (like “New device found: Alice’s Radio” showing up as discovered). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

This workflow is confirmed in the documentation: *“Contacts are discovered through advertisements broadcast by other nodes. When a node receives an advertisement: (1) it extracts the sender's identity and metadata, (2) checks if the sender is already known, (3) if not, creates a new contact entry, (4) calculates a shared secret with the sender using ECDH, (5) updates the contact's information, (6) notifies the application about the discovered contact.”*. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

So, **contact discovery is fully decentralized** – any node advertising can be found by any listening node. There’s no separate “discovery server” or anything; it’s baked into the peer-to-peer protocol at the radio level.

**Advertisement propagation:** By default, **only repeaters forward adverts** (as implied by MeshCore’s philosophy). A regular device’s `advert` is usually a one-hop broadcast (a “zero-hop” advert meaning it’s intended just for direct neighbors). However, MeshCore repeaters will periodically send **“flood adverts”** which are longer-range beacons and possibly get forwarded by other repeaters, effectively spreading awareness of their presence network-wide. If a normal node is out of range of you but within range of a repeater, and that repeater floods an advert for it, you might learn about the distant node anyway. But normal nodes won’t themselves relay someone else’s advert by default. This structured approach means that in a big network with strategically placed repeaters, you can still achieve widespread discovery without every single node yelling all the time. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

**Protocols and technologies:** The underlying transport is LoRa radio frames. MeshCore uses its own protocol on top (so it’s not using standard Wi-Fi or Bluetooth for mesh, except that some devices use BLE to connect to phones – that’s separate from the mesh). For mesh messaging, it’s pure LoRa. **LoRa PHY** provides the long-range wireless channel; MeshCore adds a custom protocol with encryption and addressing on top of LoRa. Advertisements are one type of mesh packet. They are not encrypted (or not fully) because their purpose is to share public keys and allow others to begin secure comms. They may be authenticated with a signature – it’s not explicitly stated in the docs we have, but given the system’s use of Ed25519, it’s likely that the advert contains a signature proving it was generated by the holder of that private key. This would prevent spoofing of adverts (more on security below). The deepwiki does mention adverts broadcast the public keys and note that addressing is cryptographically verifiable, which suggests there is a check (the node address hash ties to the pubkey). Even if an advert were unsigned, an attacker broadcasting a fake pubkey can’t actually complete the ECDH handshake or decrypt anything meaningful, so they gain nothing but maybe a dummy entry on your list. In practice, the security of contact exchange relies on the cryptography rather than secrecy of adverts. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

**Name conflicts and resolution:** Since contact names are chosen by users and not guaranteed unique, it’s possible to have multiple contacts with the same name (e.g., two people both name their device “MeshNode”). MeshCore does not attempt to globally resolve such conflicts – it simply stores the name each device calls itself. The unique key is the identity (pubkey). In the app, you might see two “MeshNode” entries, but under the hood they have different IDs. The system distinguishes them by identity, and there’s no automatic renaming or merging. It’s up to the user to handle if this is confusing – one could edit the local name of a contact (if the app allows editing the contact alias) or ask one of the users to pick a different nickname. There have been edge cases: for example, due to a bug in one MeshOS version, some devices had identical keys, causing a real conflict (two devices truly appeared as one, since their identity was inadvertently the same). In that case, users saw weird behavior like a contact’s name changing to someone else’s, because the system thought it was the same identity (the first byte of the key was colliding, as one user speculated). The resolution there was to fix the root cause (ensure unique keys by reseeding randomness). Barring such rare key collisions, **contact identity collisions are practically impossible**, and name collisions are harmless albeit potentially confusing to humans. The MeshCore firmware currently doesn’t implement any special logic for name conflicts; it trusts the identity to differentiate contacts. So **no renaming or resolution is done automatically** – each advert simply updates the name for that identity, whatever it may be. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)

**Contact updates (dynamic info):** When a node’s information changes, those changes propagate via the adverts too. **For example, if a user renames their device**, the next advert they send will carry the new name. All other nodes that have that device as a contact will update the stored `name` field to the new one when they receive that advert. This can happen silently. Similarly, if a device moves and has GPS, it might include updated coordinates in adverts – others will update the contact’s GPS data accordingly. The **last advertisement timestamp** is always refreshed, and a local `lastmod` timestamp is set so your device knows it updated that record now. Essentially, **contacts are dynamic records**: they get refreshed by incoming adverts. There is no need for a separate “contact sync” message – the advert itself is the sync. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

One notable dynamic aspect is **routing information**: MeshCore might learn better paths over time. If your device hears a direct transmission from a node that was previously only reachable through a repeater, it may update the contact to note a direct path is possible (out\_path becomes direct). Or if it learns that a certain repeater provides the fastest route, it updates the stored path. These updates happen as part of receiving any message, not just adverts – if a data packet arrives via a certain route, the routing module can update the contact’s path info. The deepwiki reference on Packet Routing and Path Learning would detail that, but in short, **contact entries are updated with new routing hops as they are discovered**, ensuring the `out_path` is current. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Connection history or logs:** The contact list itself does **not** store a history of interactions (no message logs or time of last message, etc., beyond the last advert time). It’s not a connection log, just the latest state. If you want to see communication history, that’s handled elsewhere (for instance, the app keeps a chat history for messages, and the device can log events to a log file if debug is on). MeshCore’s emphasis is on real-time or near-real-time state. If you needed to get a sense of connectivity history, you’d look at device logs or analytics (e.g., debug logs might show “Contact X unreachable from time A to B” or “sent message via Y hops”). But **the contact entry itself only tracks last seen time and path, not a list of every encounter or missed message**.

**Handling stale contacts in routing:** When a contact hasn’t advertised in a long time (stale), the stored route might be outdated. MeshCore’s routing will attempt to use the known path if one exists, but if that fails, it can resort to flooding the message network-wide as a fallback. The FAQ explains that if you had a known path via a repeater that is now gone, the next message send will try that path a few times, fail, then on final retry broadcast the message so that if the target is anywhere out there (and maybe reachable by another route), it can get it. After that, it resets the known path (since it was broken). So the system is robust to stale info – it can recover by exploring the network again. The contact remains in your list regardless, and if the node comes back on a different route, you’ll rediscover the new path.

**Protocols for info exchange:** Besides adverts, **MeshCore has an “import/export contact” process** for out-of-band exchange. This isn’t a different protocol per se, it just means you can take the data normally found in an advert and share it via QR code, file, or another channel (even theoretically by reading it over phone or through a web link). The receiving device processes that data as if it had heard an advert on the air, thereby creating the contact. This is extremely useful in practice: e.g., to add a contact that’s not currently reachable by radio, or to pre-share contacts before a mission so that devices recognize each other when they eventually meet. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md)

**To summarize discovery:** MeshCore uses a **minimal broadcast approach**. Devices remain invisible until they broadcast an advert (either scheduled or manually triggered). Only those adverts exchange the necessary info (public keys especially) that allow peers to become contacts. The protocols involved are custom to MeshCore: on the radio side it’s LoRa packets, at the crypto level it’s Ed25519 (for identity and signatures) and Curve25519/ECDH (for secret exchange), and at the encryption level it’s AES for content. The **advert packets are the core of contact resolution** – they advertise identity which others then use to establish secure links. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

**Contact resolution:** This phrase can mean *resolving a contact to a network address or route*. In MeshCore, resolving a contact essentially means mapping the contact’s identity to the information needed to reach them (which is exactly what the ContactInfo provides: maybe a direct link or a path of repeaters, and the encryption key to use). If two contacts have the same name, “resolving” which is which is done by their unique keys. The system might display something like “Alice (ID: 1234ABCD)” for clarity if needed. Usually though, the resolution is automatic and internal.

**Maintaining connection logs:** As noted, there’s no per-contact log beyond last seen. However, some devices (like the room server or possibly future features) might track how often a contact connected. For example, a room server might know when each user last logged in, but that’s specific to the room server’s function, not a general mesh contact feature.

**Updating contact info changes:** The system handles it gracefully – when a node’s info changes, its adverts carry the updated info and everyone updates their local record. If a device’s role changes (say you reconfigure a node from “companion” to “repeater” and it reboots with a new type), it will advertise as type 2 instead of 1; others will update the contact type field accordingly on next advert. If a device’s **public key changes** (which only happens if you intentionally reset its identity), then it’s essentially a new contact altogether – the old contact won’t magically update its key (because that would be a security issue). Instead, you’d have one stale contact for the old key (which will never be seen again) and a new discovered contact for the new key. It’s on the user to remove the old contact if it’s obsolete. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)

In summary, **contact discovery is handled by periodic broadcast adverts** that convey node identity and metadata; **contact info exchange uses MeshCore’s own LoRa-based protocol** with cryptographic elements (public keys, ECDH). **Name conflicts are not actively resolved** by the system aside from using unique IDs under the hood. **Contacts don’t maintain communication logs**, only state, but the mesh provides acknowledgments and delivery statuses at the message layer (for example, the app shows delivered/check marks, etc., which come from the protocol’s ACK). **Dynamic updates** (like name or location changes) are picked up automatically from new adverts. MeshCore aims to keep all nodes in a mesh up-to-date about each other with as little overhead as necessary.

## 5. Security and Privacy Aspects

MeshCore was designed with security in mind, so the contact system is tightly integrated with cryptographic identity and encryption. Here’s how security and privacy relate to contacts:

**Cryptographic identity verification:** Each MeshCore node’s identity is an **Ed25519 public/private key pair**. The public key (32 bytes) is essentially the node’s global “ID.” When two nodes meet (through an advert exchange), they are essentially trading public keys. Because Ed25519 keys are used, nodes can also **sign messages**. It’s very likely that advertisement packets are signed by the sender’s private key to prove authenticity (though even if not, the subsequent encryption step ensures authenticity of any meaningful communication). When your device receives an advert claiming to be from a given public key, it could check a signature to verify that it indeed was broadcast by the owner of that key. This prevents an attacker from spoofing someone else’s identity in the discovery phase. Even in worst case (say adverts weren’t signed), an attacker cannot complete the next step (ECDH encryption handshake) without the private key, so they could at best trick you into listing a bogus contact that never successfully communicates. Thus, **contacts are inherently cryptographically verified** by virtue of the key exchange. You trust a contact’s identity because only someone with that private key could ever decrypt your messages or communicate back in a meaningful way. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

In practice, this means **spoofing a contact is extremely difficult**. An attacker can’t pretend to be an existing contact of yours unless they somehow stole that device’s private key. If they make up a new identity, they’ll just show up as a new contact (which you could choose to ignore). And if they try to impersonate by using the same name as someone, they still won’t have the same public key, so your device treats them as a separate entity. All encrypted messages are tied to the keys; an impersonator wouldn’t be able to decrypt your messages meant for the real contact (since they lack the shared secret).

**Encryption and message security:** Once a contact is established, all **direct communications are end-to-end encrypted** with the ECDH-derived shared secret (using AES-256 in MeshCore’s case). Additionally, each message includes a MAC (message authentication code) for integrity. This means that even if messages are relayed by other nodes, those intermediaries cannot read or alter the content – the message is cryptographically bound to the two endpoints (your device and the contact’s device). The shared secret in the ContactInfo is essentially the AES key for that contact. Only your device and that specific contact have that key, so privacy of conversations is assured. MeshCore thus achieves **end-to-end encryption (E2EE)** at the mesh layer. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

**Can contacts be spoofed?** Given the above, **it’s practically not possible** for an attacker to spoof an existing contact such that you would accept messages from them. If someone tried to use the same name and even claimed the same short ID, they would not have the same public key. Your device would treat them as a different contact (or might even detect a hash collision and throw an error). Moreover, if a malicious node broadcasts random adverts, your device in manual mode just lists them as unknown discovered contacts – they can’t force themselves into your added contacts unless you have auto-add on. If you do have auto-add on, a malicious node could indeed get auto-added to unwitting users’ lists by advertising. However, **they still can’t do much**: they could send encrypted messages, but you wouldn’t have a shared secret unless your device did the ECDH (which it will do if auto-added). Actually, in auto-add mode your device would compute a shared secret and accept messages – so could an attacker spam you? Potentially yes, a network spammer could auto-add on devices with that setting. But they couldn’t decipher any of your messages not intended for them.

The contact list acts partly as a **trust list**: if a contact is in your list, your device will process and decrypt messages from them. If a device isn’t in your list and you’re in manual mode, messages from them are dropped. One contributor described the contact list as “just a filter on inbound messages” – the firmware will discard messages from unknown senders to avoid spam. This suggests that even though theoretically the encryption key could be computed on the fly if an unknown sends you something, the firmware chooses not to until you add them (again, a design choice to prevent unsolicited messages). *“You don’t technically need it \[the contact entry] to receive or decrypt them but the firmware discards them to avoid spam”* – this line implies the encryption could be done, but for security (and probably UX), unknown senders are ignored. Only when you add the contact does the device fully participate in communication (storing the pubkey and allowing messages). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Privacy controls – visibility:** By default, any MeshCore node can potentially discover any other if they are in radio range or connected by repeaters, since adverts are not encrypted. This means that **your device’s existence (and name) is visible to others on the same mesh network**, unless you take steps to limit it. However, MeshCore has a concept of channels that can add privacy. If you configure your device to use a private channel (with a secret key), it will only exchange adverts on that encrypted channel. For example, if you and a group set up a MeshCore channel with a secret, your devices might encrypt or otherwise silo their adverts such that outsiders (not having that secret) either don’t hear them or can’t interpret them. Meshtastic does this with channel keys (devices on different channel keys ignore each other entirely). MeshCore’s “Channel: secret” QR format suggests a similar capability. In effect, **you can create a closed mesh** where only invited nodes (with the channel secret) can join and discover each other. This is a major privacy mechanism – it means you won’t even appear as a contact to someone not on your channel. [\[github.com\]](https://github.com/ripplebiz/MeshCore/blob/main/docs/faq.md)

Out of the box, though, MeshCore devices ship with a default open channel (often called the “All” channel) for interoperability. On that open channel, your device will be visible. So to remain hidden, one could set `advert.interval = 0` (no local adverts) and maybe not send any messages – effectively going radio-silent except for scanning. A truly stealth node could be configured not to respond at all, just listen; but then it wouldn’t participate in mesh comms beyond eavesdropping on public broadcasts (it couldn’t even decrypt others’ messages without their keys). Typically, privacy is intended to be achieved via **encryption** rather than obscurity: even if someone sees your node and name, they cannot decode your conversations or track you beyond knowing you exist. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery) [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

**Privacy of contact data on the device:** The contact list on the device is stored in flash but not encrypted at rest (there’s no mention of contacts being encrypted on disk – it’s likely stored in plaintext form on the device’s internal flash). This is pretty common for embedded devices. The threat model is that if an attacker has physical access to your device’s flash, they could read out your contact list (names, pubkeys, last seen times, etc.). That might be a minor privacy concern (they see who you’ve been near). There isn’t an explicit privacy control for that except device-level encryption which MeshCore doesn’t do (due to complexity and limited MCU resources). However, the **most sensitive piece – your own private key – is stored securely** (and could be encrypted with a passphrase, but likely it’s just hidden in internal FS). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Permissions and access control:** MeshCore implements certain **access control lists (ACLs)** for specialized nodes:

*   **Repeaters** typically don’t restrict who can use them (they forward anything). They might have an ACL concept to prevent unauthorized use, but by default MeshCore repeaters are open to all mesh traffic (since traffic is E2EE, repeaters don’t need to inspect it).
*   **Room servers** do have access control: as the blog describes, they have **password-protected roles** (admin, guest, read-only). When a room server appears as a contact, you must “log in” by providing a password to actually post messages. The contact entry for a room server might indicate whether you are logged in and what level you have. The room server itself maintains a list of who is allowed to post (who has the guest password) and who is admin. This is separate from the contact list mechanism – it’s an application-layer ACL. But it’s crucial for multi-user security because it prevents unauthorized users from dumping messages into a room they shouldn’t. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html), [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   **Sensor nodes** also likely use an ACL. The DeepWiki mentions “ACL Clients” for sensor nodes with a storage of \~128 bytes per entry. This implies a sensor can have a list of client identities that are allowed to query or receive its data. For instance, an environmental sensor might only accept commands from contacts on its ACL (perhaps the base station). This prevents random mesh participants from polling or controlling a sensor. The sensor’s contact list might effectively be its ACL (or a subset thereof). The mention of ACL being platform-specific suggests it might not reuse the ContactInfo structure exactly but something similar. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

For normal peer-to-peer contacts, **the main “permission” is whether you’ve added them or not**. Adding a contact is essentially granting them the ability to communicate with you (since now you have their key and will accept their packets). Not adding (or removing) a contact is the basic “deny” – your device will ignore them. In that sense, **not adding = blocking** at a coarse level. Currently, there isn’t a nuance like “stay in contacts but block messages from this person”; you would just remove them if you don’t want to hear them. If you leave auto-add on, you can’t selectively block one device except by later removing it (and it could come back if it keeps advertising and auto-add is still on). There was no explicit “block” feature callout in docs, but you can simulate it by manual control.

**Can contacts be blocked or filtered?** Yes, administratively by the user. For example, if a certain contact is spamming, you can remove them and possibly disable auto-add so they don’t pop back in. Future firmware might implement a specific “ignore this identity” flag, but currently the best you can do is keep them in discovered state and never add them (which means you’ll never exchange with them). Also, as mentioned, the **contact list itself filters inbound messages** – unknown senders are dropped. This default behavior means your device inherently “blocks” anyone not on your list (in manual mode). If you find someone on the discovered list annoying, you simply do nothing (don’t add them) and you won’t hear from them. If auto-add is on, you might need to actively remove undesired contacts. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Privacy of presence:** One privacy aspect is others knowing whether you’re online. Your device advertises on some schedule; between adverts, other nodes don’t necessarily know if you went offline. The “fresh/stale” concept is local – there’s no network broadcast saying “I am now offline.” So your privacy in terms of not wanting others to track your uptime might be helped by the fact that adverts are infrequent and there’s no explicit logout message. However, since adverts are infrequent, others will assume you’re stale after 12h of silence. If you want to be invisible, you could turn your device off or set advert interval to 0 so it never announces (but then you also can’t easily be contacted unless someone already has you and explicitly tries flooding a message hoping you’re there, which they wouldn’t know to do).

**Data during resets/updates:** If you reset your device (factory reset), as discussed, all contact data on it is wiped. However, what about **contact data stored on others’ devices about you**? If you leave a network or reset your identity, the old contact entries on others’ radios remain but eventually go stale. They might manually remove your old identity if they know you reset. There’s no kill signal you can send to purge yourself from others’ lists (that would be a weird feature). So, some residue remains in others’ contact lists until they clean it.

**Firmware updates:** Upgrading the firmware on your device typically preserves contacts (since they’re in the filesystem and most updates don’t erase the FS). But some firmware updates might recommend an erase (like the MeshOS entropy fix) which would mean re-adding contacts after. If you update without erasing, the new firmware will just load the existing contacts file as usual – so from a data integrity standpoint, nothing special happens to contacts during an update (no sync needed, just don’t erase the storage). The device’s contact list format has remained compatible so far (if that ever changed, release notes would instruct users accordingly). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)

**Overall security:** MeshCore uses a **dual-layer crypto** approach: Ed25519 keys for identity and ECDH, and AES for actual message encryption. This ensures that the identity of contacts is bound to cryptographic keys. It’s effectively employing a web-of-trust model: you trust that if you have added a contact’s public key (perhaps you verified it out-of-band by scanning a QR from the person themselves), then all communications are secured. There is no central authority or PKI, meaning no certificates or third-party verification of identity – it’s more like exchanging keys directly (similar to how one might exchange PGP keys or use Signal’s QR code verification). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

**Privacy controls summary:**

*   **Manual contact approval:** You decide who to add, which prevents random people from engaging you. This is the primary user-level privacy control.
*   **Channel encryption:** By using a non-default channel with a secret, you ensure that only those with the secret even see your traffic or adverts, essentially partitioning the mesh for privacy.
*   **Hidden node option:** By disabling adverts (`advert.interval=0` and not sending anything), a node can operate quietly (though it then must rely on others to initiate contact, which they might not know to do). This is an advanced/edge scenario (like a passive sniffer or a strictly client device that only sends responses and never announces).
*   **Data control:** You can export contacts to share with trusted partners, and conversely you don’t have to share with others. QR codes for contact contain the public key and name, but you’d only show that to someone you want to have your contact.

**Blocking**: If a user is harassing you on the mesh, you can remove them from your contacts. If you have auto-add on, you should switch to manual so they don’t get re-added. There isn’t a one-click “block list” where the radio refuses to even list certain identities, but that could be simulated by just never adding them (the integration could potentially auto-drop certain discovered IDs).

**Contact data on reset/update:** When you do a **device reset or firmware update**, from the perspective of *other* nodes, your node either disappears or returns with a possibly new identity. If you kept the same identity, others will just see you come online again (fresh advert after being stale). If you changed identity, others will see a new contact pop up and your old identity will never refresh (remaining stale indefinitely). On your side, if you wiped contacts, you essentially have an empty list; you would need to rediscover or re-import contacts. There’s no global service remembering your contacts for you – it’s your responsibility to back them up if needed.

From a **security standpoint**, if you give your device to someone else or repurpose it, you may want to erase contacts for privacy. The `erase` command formats the FS, which will remove contacts (and identity) completely. If you simply update firmware but do not erase, your contacts (and identity) remain – meaning if you sold a used MeshCore radio and the new owner doesn’t erase it, they might still have your contacts (and you as a contact on others might still be using the same identity, which could be odd if now someone else has it). So best practice is to factory-reset devices before handing them off, to avoid any privacy leakage. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

In conclusion, **MeshCore’s contact system is fundamentally secure**: it uses strong cryptography (Curve25519/Ed25519) to ensure contacts are genuine and communications are private. **Privacy controls** exist primarily in the form of network design (open vs closed channels) and user choice on adding contacts. While not extremely granular (no per-contact custom permissions beyond specialized nodes), the system’s simplicity (add means allow messages, not added means no messages) and the encryption of all payloads provide a high degree of privacy and protection against eavesdropping or spoofing. Advanced nodes like room servers add further access control (passwords) to manage group privacy. And finally, because no central server is involved, **your contact list is local** – it’s not uploaded anywhere, so outside the mesh radio context, nobody else knows who your contacts are. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)

## 6. Communication and Messaging Integration

The contact list is the backbone for MeshCore’s messaging functionality. Once contacts are established, they serve as the endpoints for all mesh communications. Here’s how contacts interact with messaging:

**Requirement for messaging:** To send an encrypted message to another MeshCore device, that device must be in your contacts (with a shared secret set up). If a node is not in your contacts, your radio will generally *not attempt to send to it directly*. One exception is the **public broadcast channel**: MeshCore devices can send unencrypted broadcast messages (on the default “All” channel) that any node can receive without being a contact. However, those broadcasts are like open forum messages – they are not tied to a contact and can’t be replied to privately unless the contact gets added. For private one-to-one or one-to-few messaging, contacts are essential. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl) [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

In practice, in the MeshCore app you can only initiate a chat with someone who appears in your contact list. If you haven’t added them, you either won’t see them or you’ll see them under “discovered” but grayed out for messaging. The firmware enforces that **direct messages are only processed for known contacts**. This acts as a spam filter and also as a way to ensure keys are exchanged first. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

**Sending messages:** When you send a message to a contact, your device will:

*   Look up the contact’s info to get the **shared secret** (for encryption) and possibly the last known **routing path**. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)
*   Encrypt the message payload with the shared secret (AES). It also attaches a message header with the destination (a hash of the contact’s pubkey) and source (hash of your pubkey), and possibly an incrementing sequence or timestamp. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)
*   If a direct path (one-hop or multi-hop via known repeaters) is known, it will transmit the message addressed to the contact via that route. If no specific path is known, it might send the message in broadcast (flood) mode, relying on any repeater network to deliver it. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)
*   The contact’s device, upon receiving the message, uses the source ID in the header to find the matching contact (you) in its list, retrieves the shared secret, decrypts the payload, and then can present the plaintext to the user.

**Receiving messages while “offline”:** This is a challenge in pure peer-to-peer meshes: if the target isn’t currently reachable, messages can’t be delivered in real time. In MeshCore, if you attempt to send a direct message to a contact who is not actually present, **the message will fail unless some node can store it**. Without additional help, a LoRa mesh behaves like UDP radio packets – if the other side’s radio isn’t there to hear it, the message is lost. By default, MeshCore tries a few times (with acknowledgment expected). If unacknowledged after retries, it gives up (the app might show it as not delivered).

**Offline messaging via Room Servers:** To address asynchronous communication, MeshCore introduced **Room Servers** (node type 3) as a solution. A room server is essentially a special contact that acts as a bulletin board or mailbox. If you want to leave a message for someone who is offline, you both coordinate to use a room server. The workflow would be: [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)

*   You connect (log in) to a room server contact (imagine it as joining a chat room).
*   You post a message to that room. The room server stores it in its message buffer (up to 16 recent messages). [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html), [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   Later, when the intended recipient comes online and also connects to that room server, the server will deliver the missed messages to them (it actually sends the last N messages to any client when they log in, so each client gets whatever they missed while offline). [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   The room server ensures messages persist for a while (16 messages depth by default).

So, while **direct device-to-device messages require both to be present**, using a **room server enables asynchronous messaging**. Importantly, a room server itself shows up in the contact list just like any node (with its own public key, name, etc.), and communication with the room server is also encrypted (usually the room server might use the group’s channel key or individual secrets per user – often it might use the channel concept because multiple users talk to it). The blog describes that each room server has its own login credentials but after login, “the interface looks just like any other chat”. So from a user perspective, a room is a contact that behaves like a group chat. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)

**Can you send messages to offline contacts directly?** Without a room server, **not reliably**. If you send a message and the contact’s radio is off or out of range, your message will go into the ether. The MeshCore system will try the known path and then a flood retry if enabled, but if the device truly isn’t there, nothing can be done. The message is not stored on your side for later re-send (unless the app chooses to implement such logic – currently it’s not indicated). The emphasis is on using room servers when you need a mailbox functionality. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html), [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)

**Contact status effect on routing/delivery:** The Fresh/Stale status is mostly informational, but it does give you an idea of whether your message will likely go through:

*   If the contact is Fresh (seen within 12h), chances are the device is on or at least was recently. Your message will be attempted. If the contact is truly online and in range, you’ll get an acknowledgment (MeshCore has a **definite acknowledgment** system, indicated by checkmarks in the app for delivered messages). So you will know if it was delivered. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   If the contact is Stale (not seen in 12+ hours), the device might be off. Your radio will still send the message (it doesn’t forbid it), but you may not get an ACK. After a few retries it will mark it failed. The app might still show it as sent but not delivered. Later, if that contact comes online, there’s no automatic retry from your side (again, unless using a room).
*   If you see a stale contact, you might decide to use another method – e.g., if you both had agreed on a room server, you’d post the message there instead of direct, so that whenever the other comes online the message will be forwarded to them.

**Network routing with contacts:** MeshCore tries to optimize routing using contact knowledge:

*   Each contact entry can store a **direct route (1 hop)** or a series of hops (like A->B->C) coded in `out_path`. This is learned either from receiving a message via that contact (so it knows the return path) or via routing gossip (not fully detailed in our sources, but possibly via repeater neighbor tables). [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)
*   If a contact is within one hop, obviously the path is direct. If it’s multiple hops, the device may rely on repeaters to forward. Repeaters maintain neighbor tables with link metrics (the CLI `neighbors` command shows this), which likely helps route messages. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
*   The **contact list works with the routing algorithm** in that each contact’s hashed ID is used for addressing. Repeaters don’t need to be in your contact list to route a packet; they will forward based on the destination hash in the header, even if they don’t know that node personally. But having the contact in your list told your device what that destination hash is (it’s derived from the pubkey), enabling it to set the packet header correctly.
*   If a repeater goes down, the path stored for a contact might break. As mentioned, the firmware will then flood after failures, effectively doing a route discovery by brute force. If it finds another path, it might update the contact’s path for next time.

**Different types of contacts and communication:**

*   **Chat contacts (type 1):** These are typical person-to-person contacts. They support two-way messaging, location sharing (if enabled), etc. Each of these contacts is essentially like a “buddy” in a messaging app. You can send individual messages (which are encrypted with your shared secret).
*   **Repeater contacts (type 2):** A repeater is a node that forwards traffic but typically doesn’t originate user messages. In the app, a repeater might show up in your contact list (especially if auto-add is on, you’ll see all the repeaters). You normally **don’t send chat messages to a repeater**; there’s no user behind it to read them. You might ping it for diagnostics, but generally it’s just infrastructure. The MeshCore app might even hide pure repeaters from the main contact UI (or list them separately) to avoid confusion. Repeater contacts are used by the routing algorithm internally. For example, your device might know repeater X and repeater Y as contacts so it has their keys and can send encrypted traffic through them (the traffic might be double-encrypted hop-by-hop or just end-to-end; since end-to-end encryption is used, the repeater doesn’t need to decrypt content, but it might need to read the header if doing partial routing). Typically, you don’t need to interact with repeater contacts beyond seeing signal stats.
*   **Room Server contacts (type 3):** These behave like a special kind of contact that offers a *group chat* or *mailbox* service. Communication with a room server is interactive: you “log in” (the app will prompt for a password, which is then sent to the room server for authentication). After that, any message you send to that contact is actually a post to the room, and any message you receive from it is either someone else’s post or a sync of missed posts. Essentially, the room server mediates a multi-party conversation. Technically, each client maintains a contact entry for the room server (with its own shared secret for comms with the server). The server holds messages and forwards them to each logged-in client as needed. The room server concept allows *group/broadcast messaging with persistence* without every one of those group members having to be directly connected as contacts with each other. You just need the room server contact in common. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   **Sensor contacts (type 4):** A sensor might periodically broadcast telemetry or respond to specific query commands. If you have a sensor on the network, it will advertise like any other contact (so it ends up in your list). The data a sensor sends might be in a special format (not a user chat message but perhaps a sensor reading frame). The MeshCore app or integration would likely parse those and display sensor data separately. You typically wouldn’t “chat” with a sensor, but you might send it a remote command. Under the hood, that’s still just a MeshCore message (maybe with a flag indicating it’s a sensor command) addressed to that contact. Sensors also might not advertise as frequently; some battery-operated sensors may only wake and send data occasionally. If you have a sensor contact that hasn’t sent data in a while, it would appear stale, but that’s expected until its next reading. Also, as mentioned, sensors can use an ACL – meaning a sensor might ignore commands from anyone except a specific base station’s identity that it trusts. This is a fine-grained permission outside the usual contact mechanism (the sensor firmware might check “is the sender’s pubkey on my allowed list? If not, ignore the command”).

**Group messaging and broadcasts:**

*   **Group messaging (multi-recipient):** MeshCore doesn’t do multi-recipient encryption natively (like sending one encrypted message that multiple different contacts can decrypt) aside from using a shared channel key scenario. Instead, it handles groups via the room server mechanism. That way, the complexity of addressing multiple people is offloaded to the server. Everyone talks to the server (which could be thought of as an “always on” node storing messages). This also solves the offline issue. So to have a group chat, you set up a room server contact and have all members connect to it. It’s not pure peer-to-peer for groups, but it’s a pragmatic solution.
*   One could imagine using a **shared channel** (like Meshtastic style) where all members share an AES key and just broadcast to the group. MeshCore’s channel concept suggests they might allow that: if all devices share a channel secret, then any device can send an encrypted message on that channel and all others can decrypt it. That would be a form of group messaging without a server. However, the deepwiki encryption doc mentions “authenticated group communications” as something the encryption system provides. Possibly this refers to channels (where a group of nodes share a symmetric key, so messages are encrypted with that key and are authenticated as from someone in possession of that key). The drawback is lack of message persistence if someone’s offline, which is why the room server is still useful. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)
*   So, in practice, **for real-time group chat** (where everyone is on and in range), a channel with a shared secret could allow group broadcast of messages (like a net where everyone hears it). But if the group is large or multi-hop, flooding all messages may be inefficient. They might still prefer the room server to aggregate.
*   **Broadcast messaging (one-to-all):** On the default “All” channel which is open/unencrypted, any node can send a broadcast text (for example, an emergency beacon). All nodes listening on that frequency will receive it. Since it’s not encrypted, even unrelated MeshCore nodes (just on the same frequency) could catch it, and other LoRa receivers could too, though only MeshCore ones would parse it meaningfully. Because it’s public, typically it would be used for things like initial contact or general announcements. Each device probably has a predetermined contact entry for “Public Channel” or similar in the app to allow sending broadcast messages (or the app might treat that as a special case separate from contacts – not sure, but likely separate UI for broadcasting).
*   MeshCore’s approach emphasizes using **structured roles** (repeater, room server) rather than making every device do everything. This helps performance in big networks (reducing flooding). So group comms is channeled through those specialized nodes. [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery), [\[nodakmesh.org\]](https://nodakmesh.org/blog/meshtastic-to-meshcore-device-discovery)

**Contact status and message routing:** We touched on it, but to reiterate with an example:

*   Suppose you have Contact Bob in your list as stale. You send “Hello” to Bob. Your device will still encrypt with Bob’s key and send it. Let’s say Bob is out of range but connected via one repeater hop originally, and you have that route cached. Your radio sends the message to the repeater addressed to Bob. If Bob’s device is off, the repeater will not get an ACK from Bob. It may try again a couple times (depending on network settings). After failure, your device’s firmware logs that Bob is unreachable. The final attempt might have been a flood (so any repeater or node in the network could pick it and deliver if possible), but Bob’s off, so nothing. Your app eventually shows message not delivered (maybe a red X or no check mark). Bob’s device, being off, obviously did not get it. When Bob comes online later, **your device will not automatically resend** that old message (it has no way of knowing Bob is now on, unless you manually re-send it). So direct P2P messaging has that limitation.
*   If instead you both had decided to use a room server for communication, you would have posted the “Hello” in the room. The room saves it. Bob comes online and connects to the room server – the server then **pushes the stored “Hello”** to Bob. In Bob’s app, he sees “Hello” from you, even though you were offline at that moment; it was delivered via the server. In this case, the contact enabling this was the room server contact (which both of you had to have in your list and be able to reach). [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   Now consider **repeaters and multi-hop**: Let’s say you and Bob are 3 hops apart through two repeaters. Your device doesn’t necessarily list all intermediate nodes as contacts (perhaps you have the two repeaters in contacts because you heard their adverts). But even if you didn’t explicitly add the repeaters, your device will know about them internally for routing. When you send to Bob, the message might go: you -> repeater1 -> repeater2 -> Bob. Each repeater just forwards it. They have their own neighbor tables to know that repeater2 is the next hop to reach Bob’s hash, etc. This is lower-level routing detail. The outcome for you and Bob is the same: as long as those repeaters are functioning, the message gets delivered and Bob’s contact entry on your side is updated with “delivered” status (and vice versa Bob gets the message showing your name because he has you as a contact).
*   If one repeater goes down (making Bob effectively out of reach), your device might not immediately know; it tries, fails, floods, fails, marks undelivered. Bob doesn’t get it.

**Different communication purposes by contact type:**

*   A **user contact** is for person-to-person messaging (text, maybe voice clips in future, position sharing, etc.).
*   A **repeater contact** is for network topology (no user messages but may be interrogated for diagnostics e.g., signal strength).
*   A **room server contact** is for group chat / asynchronous messaging; you “enter” it like a chatroom.
*   A **sensor contact** is for IoT data exchange; you might not text it “hello”, but you might receive periodic sensor readings or send a “report now” command. The contact allows secure delivery of those sensor packets.

The MeshCore system uses the contact list to know **where to send what**. When you type a message to a person, it picks their contact. When you post to a group (room), you actually send to the room server’s contact. If you do a broadcast (public), it might not use the contact list at all, since it’s a general address (though behind scenes, they might implement the public channel as a pseudo-contact with a known broadcast ID).

**Integration with higher-level apps:** The contact list can be seen as analogous to a buddy list in the app. The app likely listens for events like `onDiscoveredContact()` and `onContactAdded()` from the firmware, and updates its UI accordingly (e.g., move something from discovered list to main contacts when added, etc.). The app then lets you select a contact to open a chat. That chat view is tied to that contact’s identity for encryption. When you hit send, the app hands the message to the device/SDK, which looks up the contact and sends it out. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Delivery and acknowledgments:** MeshCore uses an ACK system (each message likely has an ID and the recipient’s firmware will send back an acknowledgment packet upon decrypting it). The **“Delivered” check marks** noted in the room server blog indicate that the sender knows the message got to the server and presumably then to recipients. For direct contacts, the app likely shows one check for sent, two checks for delivered (similar to WhatsApp or Signal style) once the contact’s device ACKs it. This reliability layer is part of the mesh protocol. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)

To sum up this section:

*   **Contacts are essential for encrypted messaging**: you need to have the contact so that a shared key exists for encryption. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)
*   **Offline messaging** isn’t inherently supported one-to-one; it requires a **room server** as an intermediary if needed. [\[73mesh.com\]](https://www.73mesh.com/2025/11/19/RoomServers.html)
*   **Contact “freshness” is a hint** to whether a direct message will succeed; stale likely means the person might be offline. In a mission-critical scenario, users would switch to a store-and-forward mode (rooms) or just accept that messages might be lost and try later or via other means.
*   **Group communications** rely on special contacts (rooms) or shared channels. The contact list doesn’t directly hold “a group of people” as one entry (there’s no distribution list contact type aside from the room which is a server node).
*   The **types of contacts inform their communication use**: you don’t chat with a repeater, you use a room server for multi-user chats, etc. The MeshCore UI likely segregates or labels these.
*   **Broadcasts to all** are possible on the open channel but are not tied to contacts; they’re more like an open CB radio call. They bypass the contact system’s encryption (since everyone needs to hear it, it’s unencrypted or uses a known global key).

## 7. Technical Implementation Details

This section covers some lower-level implementation points, such as file formats, indexing, commands, and maintenance relevant to contacts:

**Storage format:** As noted, contacts are stored in a binary file (`/contacts3`). The file is formatted as a sequence of fixed-size records (152 bytes each). The device’s firmware uses the DataStore class to read/write this file. On loading, it reads each 152-byte slot in turn and rebuilds the in-memory ContactInfo array. On saving, it writes the array back out record by record. The file path and format have version numbers in their name (contacts3 implies this is the 3rd iteration of the contacts schema; earlier versions might have been `contacts` or `contacts2` with slightly different sizes). Similarly, channel info is in `/channels2`, etc.. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage) [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Lazy writes:** The DataStore implements a **lazy write delay of 5 seconds** after any contact modification. This means if, for example, five new contacts are discovered in quick succession, the firmware will mark contacts as “dirty” but wait a bit, and then write all changes at once to flash. This reduces flash wear and improves efficiency. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**In-memory structure:** In memory, the contacts are likely kept in an array of `ContactInfo` of length MAX\_CONTACTS (350). The `num_contacts` field tracks how many are actually used. There may also be an index array (the docs mention `sort_array` and search indices). The firmware provides methods like `addContact()`, `removeContact()`, `lookupContactByPubKey()`, `searchContactsByPrefix()`. These suggest: [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

*   `lookupContactByPubKey(pub_key)` does a direct search (probably linear, unless they use a hash table keyed by the 4-byte prefix for speed).
*   `searchContactsByPrefix(prefix)` likely allows searching by a partial text or partial ID for user interface (maybe to autocomplete names or find by node ID).
*   `searchPeersByHash()` could be to find matching short hashes in case of routing or neighbor info. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/2.3-contact-and-connection-management)

**Indexing and lookup:** MeshCore heavily uses **hash prefixes** for identifying contacts in networking. Each identity has a 4-byte “sha256\_prefix” stored (the first 4 bytes of SHA-256(pubkey)). This is what’s used in radio headers as the short address. There is also mention of using first 7 bytes of pubkey as a key in the adv blob store for lookup, which might be used to quickly find which contact a given advertisement belongs to (7 bytes is extremely low collision risk across the network). So the firmware might maintain a map/dictionary from these prefixes to contact indices for quick lookup when a packet arrives addressed to, say, 0x89AB3CDE, it can map that to contact X’s pubkey.

For name-based lookup (like user typing in a name), it might use `searchContactsByPrefix` on the name field.

**APIs and commands:**

*   **Device CLI commands:** MeshCore firmware includes a built-in command-line interface accessible via serial/USB or Bluetooth console. Some relevant CLI commands and settings: [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `advert` – manually send an advert now. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `erase` – wipe filesystem (which clears contacts and everything else). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `get name` / `set name <text>` – to view or change your node’s name (which your adverts broadcast). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `get public.key` – to retrieve your node’s public key (for manually sharing, if needed). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `get advert.interval` / `set advert.interval <minutes>` – control how often (in minutes) you send a local advert beacon. By default, after initial setup, this is 0 (off) for companions, meaning they don’t auto-advertise often\*\*.\*\* Repeaters use `flood.advert.interval` in hours for network-wide adverts. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference), [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference) [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   There isn’t an explicit documented CLI command shown for listing contacts. Possibly the CLI doesn’t have a user-friendly way to dump the contacts (or it might and just not be in this excerpt). There might be a hidden command or one could use `log` to see contacts as they’re discovered.
    *   `neighbors` – on a repeater, this shows neighbor table (which isn’t exactly contact list, but radio link info like RSSI for each neighbor node). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
    *   `allow.read.only` – a room server setting to allow no-password read access (tied to contact type behaviors). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
*   **Mobile/desktop APIs:** There is a Python API (`meshcore` PyPI package) and presumably a BLE GATT interface and a serial protocol for apps to talk to the device. These APIs let applications manage contacts as well. For instance, Home Assistant’s integration calls an SDK function `set_manual_add_contacts(True)` to toggle manual mode, and functions like `meshcore.add_selected_contact` to add a discovered contact via the app UI. So under the hood, the device likely offers a command or message to add a discovered contact (basically move it from discovered list to main list). [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)
    *   The existence of an open Issue requesting an “auto-add with hop limit” indicates currently the control is just auto-add on/off globally. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546)
*   **Import/Export functions:** The firmware has `exportContact()` and `importContact()` methods. These take a contact’s data and produce a serialized blob or take a blob and create a contact. This is how scanning a QR code string (like `meshcore://contact/add?...`) gets turned into a new ContactInfo on your device. This appears to be implemented by enqueuing a loopback of a fake advert packet into the normal receive path – essentially tricking the device to think it “heard” an advert with that info, triggering the normal handling. [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication) [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication)

**Firmware updates and contact sync:** Typically, when you flash new firmware:

*   If it’s a minor update and you keep the same identity and contact file, on first boot the firmware might check if the contact file exists and, if so, loads it. If the format changed and it detects mismatch, ideally it would migrate it or at least not crash. So far, going from `contacts2` to `contacts3` presumably happened in older development and now it’s stable.
*   If the update says “please erase device before upgrading” (like going from MeshOS 1.08 to 1.10 because of key issues), then you have to re-add contacts after since that erasure will remove them. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   There isn’t a dynamic sync needed on update because the data is local. Just ensure backup if needed and re-import.

**Diagnostic tools for contacts:**

*   The CLI’s `log` functionality can log events to a file. If you enable logging (`log start`), the device will record events like new contact discovered, key exchanged, messages sent/received, etc., to an internal log which you can later dump via `log`. This is useful to troubleshoot contact-related issues (like if contacts aren’t being added or if messages aren’t delivered, the logs can show what happened).
*   **Serial monitor**: You can connect via USB and use a serial monitor at the right baud to see real-time debug output. The troubleshooting guide encourages doing this to see exactly what’s happening on the mesh. The firmware likely prints messages like “\[INFO] New contact discovered: 89AB3CDE (Alice) via repeater XYZ” or “\[WARN] Contact list full, cannot add ...” etc. Those logs are invaluable for debugging network problems. [\[localmesh.nl\]](https://www.localmesh.nl/en/meshcore-network-troubleshooting/), [\[localmesh.nl\]](https://www.localmesh.nl/en/meshcore-network-troubleshooting/)
*   The `neighbors` command (for repeater) helps verify which contacts are directly reachable and with what signal, which indirectly tells you if your contact entries reflect actual connectivity.
*   There might also be commands like `get contacts.count` (just speculating) or similar to check how many contacts are stored.
*   If a contact database gets corrupt or overloaded, the `erase` command is the nuclear option to start fresh (clearing out any bad data).

**Edge cases and issues:**

*   The GitHub issues show some scenarios: e.g. at \~299 contacts, UI mis-indexing happened; those are software bugs rather than design. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   Another issue was identical private keys causing a contact confusion – fixed by ensuring key uniqueness (which is a one-time setup issue). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   Another suggests decoupling app and radio contact storage (maybe in the future the app will keep a larger address book and only load needed ones into the radio). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   There's an open issue to allow auto-add with limits – might be implemented in future firmware where you can set e.g. `set auto_add_hops 2` (not currently available, but likely planned by developers due to user demand). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1546)
*   Also an issue asking if it’s better to remove contacts from discovered file after adding (perhaps to avoid duplication in app storage) – implying the app integration had both an “Added Contacts” store and a “Discovered Contacts” store and the question was whether to clear discovered once added. That’s more of an app logic detail.
*   A closed issue about increasing contacts was resolved by acknowledging hardware limits and recommending manual management (no big code change, just documentation).

**APIs for integration:** Home Assistant, for example, treats discovered vs added contacts as separate entities and even provides a service call `meshcore.add_selected_contact` to move one from discovered to contacts. That shows that programmatically one can manage contacts. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)

**Firmware data alignment:** The structure shows some padding (e.g., an `unused` byte at offset 66), likely for alignment or future flags. It also shows `sync_since` field was repurposed from reserved, etc. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)

**Memory management:** One caution from a user: *“the whole contact DB gets loaded into RAM”*. On nRF52 devices with limited RAM, 350 contacts \* 152 bytes = \~53kB, which is not trivial but okay given maybe \~256k RAM available. On ESP32 it’s fine. On some devices with less memory, pushing contacts to 1000 (which would be 152kB) might strain things, causing performance issues as observed. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**File system size:** Some boards (like T1000E) have smaller flash, so 350 contacts plus other data nearly filled it. At 450 contacts it errored that FS is full when it wasn’t clearly visible why. Possibly they have an internal flash partition that was fixed and got exceeded. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Concurrent access:** The design is single-threaded in terms of contact modifications. They likely ensure no two events write contacts simultaneously. The lazy write timer helps serializing writes.

**Backup/restore of contacts:** Right now, backing up contacts means either not erasing between firmware updates or manually exporting. There’s no “cloud backup” or such. But someone could script reading out all contacts via the CLI (if a CLI command existed, perhaps not directly, but maybe by reading the file in a maintenance mode).

**Troubleshooting commands:**

*   If a contact isn’t communicating, one might use `neighbors` to see if you have connectivity to them via any repeater.
*   Use `advert` to force them to be discovered if in range.
*   Use `log` to see if adverts or messages are arriving.
*   If contact list is acting weird, consider `erase` to reset and re-add critical contacts, as per guides if corruption suspected (they specifically have steps for wiping certain problematic devices to fix issues, which would reset contacts). [\[localmesh.nl\]](https://www.localmesh.nl/en/meshcore-network-troubleshooting/)

In summary, **the technical underpinnings** of MeshCore contacts involve:

*   A fixed record binary storage with lazy commit,
*   Use of cryptographic identities (Ed25519 keys) as the primary key with hashed short addresses for actual radio addressing,
*   A robust internal API for managing contacts (add/remove/import/export/search),
*   Tools for users (CLI commands, integration services) to control contact behavior (auto-add mode, manual add, advertise, etc.),
*   No network-wide database – each device is authoritative for its own contacts (the note “radio is the single source of truth” in an issue is referring to how the radio’s contact limit dictates the app’s contact list). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Diagnostic commands:**
While no direct “list contacts” command is documented, one can glean contact info via debug:

*   The CLI `get public.key` gives your own, but not others’.
*   Possibly an undocumented `contacts` command might list all or a subset. The Node Ninja cheat sheet might have more (result \[5] hints at some compiled list of commands).
*   However, generally the app is used for viewing contacts.

Finally, **during firmware updates**, the developer ensures backward compatibility of the contact storage or provides migration. For example, if a new field were added, they might version the file. But nothing in current FAQs indicates any manual migration needed aside from that one key fix scenario.

## 8. Operational Characteristics

In real-world use and deployment, several operational considerations arise for the MeshCore contact system:

**Typical contact list size:** This can vary widely:

*   In a **small deployment** (say a group of 5 hikers with MeshCore radios), each device will only have those 5 (plus maybe a repeater if one is used). That’s well below any limits.
*   In a **community mesh network** (like those forming in some countries), one’s device could “see” dozens or hundreds of nodes. For example, users in the Netherlands report “thousands of repeaters and users” in the country. A device in a city might hear a few hundred of them via multi-hop. Indeed, some have hit the 300 contact cap and requested to increase it. So on an active public mesh, it’s not unusual to accumulate on the order of 100–300 contacts. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   The MeshCore devs set 300 as a safe default, expecting that might suffice for most cases. But early adopters in dense areas already push that envelope. As we saw, on high-end devices people experimented with \~1000 contacts stored (though with performance issues). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   So **“typical” size depends on context**: For personal/team use, 10 or fewer. For city-wide emergency prep network, maybe 50–100. For country-wide open network, upper hundreds. At the moment, 300 is the practical maximum with default firmware, so that kind of caps typical usage unless modified.
*   It’s worth noting that not every contact in the list implies active use. Many might just be distant nodes you rarely interact with. But they still consume a slot if auto-added. This is why manual mode is recommended in large nets: so your list contains only the nodes you care about (like nearest repeater and team members) rather than every single node seen.

**Performance impact:** Large contact lists can affect performance mainly in:

*   **Memory usage:** As discussed, filling near 300 uses tens of KB of RAM. Going beyond that can strain microcontrollers with limited RAM, potentially causing slower performance or even instability if memory gets tight.
*   **Lookup time:** Searching through a list of 300 entries is trivial (microseconds) for a microcontroller, so that’s fine. Even 1000 isn’t huge for search, especially if they use hashed indexes. So message handling shouldn’t slow down noticeably just from count.
*   **Maintenance tasks:** If auto-add is on in a busy area, the device might be writing to flash a lot as new contacts roll in rapidly. This could cause momentary delays (during flash writes) or increased battery draw. The lazy writer helps mitigate continuous writes, but if dozens of contacts come in, it will flush multiple times. Still, this is a minor overhead relative to RF operations.
*   **UI performance:** On devices with screens (like T-Echo or T-Deck), listing 300 contacts might be slow to scroll or update. Indeed the bug around misalignment at 299 suggests the UI code had trouble with near capacity lists. Also, rendering a long list might be slow if the UI library is basic. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   The developers noted having 1000 contacts “does not run well” on some hardware. That could mean the device became sluggish or crashed due to low memory. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   **Radio performance:** Indirectly, if you have hundreds of contacts and especially if auto-add is on, your node might be spending often time processing adverts from all of them (though processing an advert is quick). The bigger potential issue is **airtime**: if many nodes are advertising and chatting, the air gets busy, which could lead to collisions and retries (affecting network performance). But that’s a network scaling issue not exactly the contact list itself, though they correlate (lots of contacts means lots of nodes active).

**Battery life considerations:**

*   The contact list size itself has minimal effect on battery. The real battery killers are radio transmissions and listening.
*   However, consider that in a network with 100 contacts, there will be more frequent adverts and messages flying around than in a network of 5. So your radio will be **listening and processing more often**, which does increase power consumption. Each received LoRa packet that the MCU wakes up to process draws power.
*   If auto-add is off, you might also choose to turn **contact discovery off entirely** in settings (like the HA integration allows disabling discovery to reduce overhead). That means the device would ignore adverts from unknown devices – saving some processing and memory. [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/contacts/)
*   Another factor: If you have many contacts marked fresh, your device might be sending periodic acknowledgments or link keepalives to maintain routing paths (though not sure if MeshCore does periodic pings – likely not beyond adverts).
*   The **advertisement interval** has a direct battery impact: a shorter advert interval (say every 1 minute) gives snappier discovery but uses more power. The default for companions is to effectively not do periodic adverts (advert.interval=0 except perhaps one initial advert), which conserves battery – your device isn’t shouting every few minutes, maybe only hears others or sends when necessary. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
*   *“Increase the broadcast interval from 15 to 30-60 minutes”* is a tip in troubleshooting to improve battery for nodes that were broadcasting too often. This suggests some might set a shorter advert interval manually and then see battery drain.
*   Also, if you have *many contacts on the network*, a node might be receiving a lot of traffic (others’ chats, etc., even if not intended for it, if flooding is used). But thanks to addressing, it might drop those quickly if not relevant (though it still expends energy demodulating them).
*   In essence, the **contact system is designed to minimize idle chatter**, which helps battery: only repeaters do periodic floods (and even that by default is every 12 hours), and normal nodes mostly stay quiet until needed. [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)

**Best practices for large networks:**

*   **Use manual contact management:** Don’t auto-add everyone. Instead, add only key contacts: for example, add the nearest 1-2 repeaters you trust for routing, and add your team members. Let all other nodes remain “discovered” or even disable discovery entirely if you don’t care about random distant nodes. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   **Favor “favorite” contacts:** MeshCore has a favorite flag. Possibly the UI or future features might allow prioritizing favorites (e.g., not purged, or shown on top).
*   **Export/Import contacts for device changes:** Maintain a backup of important contacts (maybe in a note or by keeping QR screenshots) so you can quickly restore them if you have to reset or swap devices.
*   **Use room servers for groups:** Instead of having every individual in a community add everyone else (which doesn’t scale combinatorially), have one or a few room servers for community chat. Then each device only needs the room server contact (plus maybe a couple repeaters), no matter how many are in the group. This drastically reduces contact list size on individual devices. For instance, 100 people in a group: if done pairwise, that’s 99 contacts each (9900 total pairs in network). If done via a room, each just has 1 contact (the server) for that group (and maybe a handful of friend contacts for side chats).
*   **Partition the network with channels:** If you expect two communities in the same area that don’t need to talk, put them on different channel secrets so they won’t see each other’s adverts. This way, each device only tracks contacts from its own community, not the other.
*   **Regularly purge unused contacts:** For devices that move through different regions (e.g., a traveling operator), you might accumulate contacts from various places. Periodically remove ones you no longer encounter to free space. Perhaps sort by last seen and remove those stale for months (except important ones).
*   **Firmware updates:** Keep devices updated, as improvements often optimize performance in larger networks (e.g., they might refine how adverts are handled or how memory is managed as the community provides feedback).
*   **Monitor contact count:** Through the app or CLI, be aware of how many contacts you have. If approaching the limit (\~300), start pruning or turn off auto-add to stop new additions. There was even discussion of implementing a FIFO removal (remove oldest unseen contact when new ones come) or mark some as favorite to avoid removal – but currently that’s not automatic, it’s an idea. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   **Device differences:** Know your device’s capability. For example, a Heltec T-Deck with 8MB flash and more RAM can arguably hold more contacts reliably than a tiny sensor node with 512KB flash. If you run the same firmware limit on both, the smaller device might hit storage issues first. So consider reserving heavy contact loads for beefier hardware (like gateways) and keep smaller nodes on lighter loads (like they might only know the gateway, not everyone). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)

**Behavior differences by device type:**

*   **Handheld/Companion devices (battery-operated, user-facing):** These default to *auto-add off* to avoid waste, *advert off* to save battery until user explicitly does something, and do not forward others’ packets. They rely on repeaters for multi-hop. They typically have UI or are connected to phone apps, so they display contacts and let user manage them. E.g., the T-Echo (with a display) or a smartphone paired via BLE will show contacts and statuses.
*   **Base station or USB-tethered node:** If you have a MeshCore node connected to a computer (running as a gateway), it might be configured similarly to companion (no automatic repeating unless set), but since power isn’t an issue, you might allow it to auto-add or to frequent advertise. A base station could theoretically handle more contacts due to stable power and possibly more memory (if something like a Pi running a variant).
*   **Repeaters (usually always-on, plugged in or solar):** They have `repeat=on`, so they forward traffic. They also by default send out flood adverts every few hours. Repeaters likely auto-add any node they hear (since as infrastructure they kind of need to know as many as possible to route). Even if they didn’t formally “add” them in a user sense, they must keep track of neighbors. *How do repeaters handle contact list?* Possibly, a repeater’s firmware could add every node it hears as a contact up to the max. It might be beneficial for a repeater to have a large contact capacity because it’s linking many nodes. If it hits 300, that could limit network size unless it also prunes stale ones. Perhaps in repeater firmware, they might treat it differently (but likely not; it’s probably the same code, just running with a repeater role flag). [\[wiki.meshcoreaus.org\]](https://wiki.meshcoreaus.org/books/doc-firmware/page/doc-cli-reference)
*   **Room servers (often running on more capable hardware like an ESP32):** These likely maintain not just the contact list but also a message database (the 16-message buffer). They might also maintain a list of logged-in users separate from contacts (e.g., track which identities have logged in with proper password). A room server might not need to have *all* its clients in its contact list, interestingly. Communication client->server uses server’s pubkey (so client has server as contact). Communication server->client might require the server to have the client’s pubkey to encrypt messages to them. So yes, the room server probably adds each user as a contact when they log in (so it can send them stored messages). If the room sees hundreds of users over time, it might fill its contact list too! (This is a scenario to consider – a public room server in a huge network might need a larger contact list.)
*   **Sensor nodes:** These likely have either a special firmware variant or a config where `auto_add_contacts` might be false (to avoid filling with irrelevant contacts). A sensor might instead be pre-loaded with one or two contacts it should talk to (like its gateway). It could even run in a mode where it doesn’t maintain a full contact DB, but rather uses an ACL list to validate commands. The storage table for sensors (ACL Clients) might basically store the public keys of controllers allowed (like 128 bytes per entry, enough maybe to store a 32-byte key + label). This implies a sensor might not reuse the ContactInfo structure fully, but a simplified version just for ACL (maybe no name needed, etc.). The documentation suggests sensors not using the main contact DB but a separate ACL file. So a sensor might not count contacts the same way – it might be in a network but not adding every node it hears, only acknowledging commands from those on its ACL. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/8.4-contact-and-channel-storage)
*   **Hybrid roles:** Some devices can act as both repeater and room server, etc. But usually firmware is dedicated (the FAQ lists separate firmware builds for repeater vs companion vs room server).

**Monitoring and logging:**

*   Users can monitor mesh health by observing contact status changes (if a usually Fresh contact goes Stale unexpectedly, maybe they went out of range or device died).
*   Many integrations (like Home Assistant) expose contact status (fresh/stale) and even create entities for each contact to track their state and last seen time. This is helpful for, say, automation (e.g., alert if an important repeater goes stale).
*   A timeline of adverts could be logged to see how frequently each contact advertises.
*   The **LocalMesh troubleshooting guide** suggests systematic debugging for issues like “node won’t connect (no contacts showing)” – solution: check frequency/region, make sure both on same channel, etc.. That highlights that if contacts aren’t appearing, often it’s a config mismatch (no adverts heard because of different channels or frequencies). [\[localmesh.nl\]](https://www.localmesh.nl/en/meshcore-network-troubleshooting/)
*   They also mention to check logs for messages routing via repeaters to ensure connectivity.

**Differences across hardware:**

*   Some devices (like Heltec V3 watch) had Bluetooth issues, unrelated to contacts but affecting connectivity to app. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1468)
*   Some older firmware had known bugs as we saw. The MeshCore development is active (stars and forks on GitHub show interest), so features evolve.

**Security recap in ops context:**

*   Users should manage their channel secrets (don’t share them publicly if you want privacy).
*   If device compromised, consider others may remove that contact or you revoke it by not using that identity.

**Summarizing operational tips**:

*   In a **large mesh**, keep your contact list lean: add key nodes (like local repeater and a few peers) and rely on them for broader connectivity. Disable auto-add to avoid clogging up with far-off nodes. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/issues/1121)
*   **Monitor storage**: if you approach \~250-300 contacts, start cleaning up to avoid hitting the cap at an inconvenient time.
*   Use **multiple room servers or channels** to segment huge user bases. For example, a city-wide network might have different “rooms” for different neighborhoods rather than one giant room with 1000 users (which one server might not handle well contact-wise).
*   **Update firmware** for improvements. For instance, if an update raises MAX\_CONTACTS for certain boards or optimizes memory, that’s beneficial (maybe in future versions).
*   For **device-specific differences**: e.g., the RAK WisTag had minimal onboard storage, so treat it differently (maybe use it as sensor or limited node only).
*   **Power vs battery**: If you have a mains-powered device (like a stationary gateway), you could allow it to auto-add liberally so it acts like a directory of the network, whereas battery devices should be conservative.

***

This comprehensive overview should equip you with an understanding of MeshCore’s contact system — from how contacts are formed and stored, through their role in secure messaging and network function, to practical advice on managing contacts in various scenarios. MeshCore’s design balances **decentralization** (each node manages its own contacts via crypto identities) with **pragmatism** (using repeaters and room servers to scale up), all while maintaining a strong security posture (end-to-end encryption and authentication from the contact level upward). With this knowledge, you can confidently implement and utilize the MeshCore SDK’s contact-handling features in your project, ensuring you correctly manage discovery, storage, and messaging for all your mesh network peers.

 [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.1-identity-and-authentication), [\[deepwiki.com\]](https://deepwiki.com/ripplebiz/MeshCore/9.2-message-encryption-and-acl)
