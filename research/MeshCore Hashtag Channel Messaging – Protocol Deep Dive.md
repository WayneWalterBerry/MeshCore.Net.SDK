# MeshCore Hashtag Channel Messaging – Protocol Deep Dive

[\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

## 1. **CMD\_SEND\_CHANNEL\_TXT\_MSG (0x03) – Payload Format**

**Format:** The `CMD_SEND_CHANNEL_TXT_MSG` payload begins with the command code `0x03`, followed by fields indicating message type, channel, timestamp, and the message content. Unlike direct messaging, there is **no recipient address or contact key** in this payload – instead a channel identifier is used. The exact byte-level structure is: [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   **0:** `0x03` – Command code for *“Send Channel Text Message”*. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)
*   **1:** `txt_type` (1 byte) – Text message type (e.g. `0x00` for plain text). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)
*   **2:** `channel_idx` (1 byte) – The target channel’s numeric ID (see Section 2). For example, `0x00` for the default “public” channel. *(In current firmware, only `0x00` (public) is typically used unless additional channels are configured.)* [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)
*   **3–6:** `sender_timestamp` (4 bytes, little-endian) – Unix epoch timestamp of the message (seconds since Jan 1, 1970) provided by the app. This allows the device to tag the message with the sender’s time. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)
*   **7–…:** `text` (N bytes) – The message content string, typically UTF-8 text, followed by a null terminator (`0x00`). The text occupies the remainder of the frame after the fixed fields. Maximum message length is limited (around 160 bytes minus some overhead for names) to fit in a single LoRa packet. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Minimum payload size:** 7 bytes overhead (through the timestamp) plus at least 1 byte for the message (e.g. an empty message would still include a `0x00` terminator). This aligns with the protocol spec which lists “**7+ bytes**” for this command. By contrast, the direct message command (`CMD_SEND_TXT_MSG` = 0x02) has **14+ bytes** because it includes a 6-byte contact identifier (see Section 5). [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

**Example – Sending “Hello World” to #bot:** Suppose channel `#bot` is configured as channel index 1 on the device. A correct payload (excluding framing bytes) would be:

    03 00 01 <timestamp> 48 65 6C 6C 6F 20 57 6F 72 6C 64 00

Breaking this down: `0x03` (command) → `0x00` (plain text) → `0x01` (channel 1 for #bot) → `<timestamp>` (4 bytes, e.g. `0x64 0x3A 0x9E 0x63` for a Unix time) → ASCII bytes for “Hello World” (`0x48 0x65 0x6C 0x6C 0x6F 0x20 0x57 0x6F 0x72 0x6C 0x64`) → `0x00` string terminator.

When you send this frame to the device (with proper frame length and start-of-frame markers, if using the USB serial protocol), the firmware will parse the fields as: Command=3, Type=plain text, Channel=1, Timestamp=X, Message="Hello World".

**Device Response:** If the payload is well-formed and the channel is recognized, the MeshCore device will reply with a status code indicating the message was accepted (see Section 3 for responses). An incorrectly formatted payload (e.g. including a channel name string where a numeric ID is expected) will **fail parsing and return an error** (often an “Invalid Command” response). [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

## 2. **Hashtag Channel Addressing (Name vs. ID)**

**How channels are addressed:** Internally, MeshCore **identifies hashtag channels by numeric IDs**, *not by their name strings*. The “#channel” names (like `#bot` or `#general`) are user-friendly labels, but on the protocol level the `CMD_SEND_CHANNEL_TXT_MSG` uses a one-byte `channel_idx` to specify the target channel. For example, the **public/default channel** is represented as `channel_idx = 0x00` (this corresponds to the main “All” broadcast domain that all nodes share by default). If you have additional channels configured (say a channel named “bot”), that channel will be assigned a numeric index (e.g. 0x01 for the first custom channel, 0x02 for the next, etc.) in the device’s channel table. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[MeshCore C...tem Techni | Word\]](https://microsoft-my.sharepoint.com/personal/wayneb_microsoft_com/_layouts/15/Doc.aspx?sourcedoc=%7BC8A9C280-FB5F-4DEB-BBCB-B505CE5693C2%7D\&file=MeshCore%20Contact%20System%20Techni.docx\&action=default\&mobileredirect=true\&DefaultItemOpen=1)

> **Note:** The channel name **is not included** in the send command payload. In other words, you do **not** send `"#bot\0Hello World"` or similar; the device won’t parse a text name there. Only the byte value for the channel ID should be sent. The firmware knows the human-readable name associated with that channel ID from its configuration, but the name never goes over the wire in the send command. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Channel ID vs. Contact addressing:** This is fundamentally different from direct messaging. In a direct message (`CMD_SEND_TXT_MSG`), you provide a 6-byte **contact public key prefix** to identify the recipient in your contact list. For a channel message, you provide a 1-byte **channel index** instead – instructing the device to broadcast to that channel group. All nodes that have that channel in common will accept the message. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Reserved channel IDs:** Currently, **`0` is reserved for the primary “public” channel** (often shown as `<public>` or `#general`). The MeshCore protocol indicates non-zero IDs can represent other channels, but they must be set up first (see Section 4). At present firmware versions, `channel_idx` values beyond 0 might be restricted or unused unless channels are configured. (In the receive path, the protocol still includes a channel index field so that in the future or in multi-channel scenarios the app knows which channel a message came on, though if only one channel is used it will always be 0.) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Implication:** To send to `#bot` or `#general`, ensure you use the correct numeric ID in the payload. If `#general` is the default channel, use `0x00`. If `#bot` corresponds to channel 1 in the device’s memory, use `0x01`, etc. **Do not include the `#` or the name string** in the command. Including the channel name as text in the payload will cause a parse error or an “unsupported command” response (since the firmware doesn’t expect alphabetic bytes in place of the channel index). [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

## 3. **Protocol Examples and Responses**

Let’s walk through the expected behavior with concrete examples:

*   **Sending “Hello World” to #bot:** (Assume `#bot` is channel index 1 as above.) You would send the byte sequence:\
    `0x03  0x00  0x01  <timestamp_4bytes>  "Hello World"  0x00`\
    The frame length byte and framing markers (for the USB/serial transport) need to be added as per the MeshCore framing protocol (e.g. for USB, prefix `>` and length). For brevity, we focus on the payload content here.

    **Device Acknowledgment:** Upon receiving the command, the device will immediately respond with a **status code frame**. In MeshCore, a successful send does **not** return `RESP_CODE_OK (0)` but rather `**RESP_CODE_SENT (0x06)**`. This response indicates the message has been queued for transmission over the mesh. It includes some additional info: a flag indicating flood vs direct send, an “expected ACK” hash, and a suggested timeout. For a channel message, the *flood flag will be 1* (since it’s a broadcast) and there typically won’t be a follow-up ACK (see below). Essentially, `RESP_CODE_SENT` means the command was valid and the radio will attempt to send the message. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

    Example: The device might return a frame like: `06 01 <ACK-hash 4 bytes> <timeout 4 bytes>`. Here `0x06` is the response code, and `0x01` indicates the message is being sent via flooding (broadcast). The ACK hash and timeout are primarily relevant for direct messages; in flood mode, they are present but since no single receiver is expected to ACK, you likely won’t get an ACK confirmation (see below). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   **Expected vs. Actual ACK:** For direct unicast messages, MeshCore uses an acknowledgment system: the `RESP_CODE_SENT` contains an `expected_ack` token, and later the device may send a `PUSH_CODE_SEND_CONFIRMED` (0x82) when the target node acknowledges delivery. **For hashtag channel messages, there is no end-to-end ACK from all recipients** – they are generally sent in flood mode as fire-and-forget broadcasts. Thus, you will typically get the immediate `RESP_CODE_SENT` (with `is_flood=1`) but **no subsequent “confirmed” push**, because not every node on a channel will send back an ACK. The MeshCore docs treat broadcast messages as delivered on a best-effort basis (there’s no collective ACK). The `PUSH_CODE_SEND_CONFIRMED` is mainly for direct messages. (If your network has a routing layer that chooses one node to ACK or something, it’s not described in the standard behavior – assume no ACK for channel messages.) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   **Device processing:** Once queued, the device will transmit the “Hello World” to all nodes listening on that channel (#bot). On the sending side, no further action is needed except possibly logging the `RESP_CODE_SENT`. On receiving nodes (others on #bot), the firmware will deliver a `RESP_CODE_CHANNEL_MSG_RECV` event to their host (or, if using offline sync, it will be pulled via `CMD_SYNC_NEXT_MESSAGE`). That frame contains the channel index and the message content so the app knows it came via #bot. For example, a receiving node might get: `0x08  0x01  0xFF  0x00  <timestamp>  "Hello World"\0` (code 8 = Channel Msg Received, channel\_idx=1, path\_len=0xFF if one-hop/local, txt\_type=0, plus text).

*   **Error scenarios:** If you send to a channel that isn’t known or available on the device, the device will respond with an error. In MeshCore, errors come as `RESP_CODE_ERR (0x01)` accompanied by an error code byte. Two likely error codes are: **`ERR_CODE_UNSUPPORTED_CMD (0x01)`** if the payload was malformed (e.g. wrong length or invalid fields), or **`ERR_CODE_NOT_FOUND (0x02)`** if the payload was well-formed but refers to a channel that doesn’t exist. In practice, if you mistakenly send a channel name string or omit required fields, you’ll hit an “unsupported command” error (the device didn’t even recognize the command structure). If you send a proper `0x03` frame with a channel index that the device has no record of, you’d get a NOT\_FOUND error (the firmware understood what you wanted but has no channel by that ID). Either way, the host SDK would likely report an **InvalidCommand or similar error**, as you observed. The key is to use the correct format and ensure the channel is configured. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   **Response code summary:** To recap, when everything is correct, sending to a channel yields `RESP_CODE_SENT (6)`, not a plain OK. Only if the device truly cannot queue the message (invalid input or disabled feature) will you get a `RESP_CODE_ERR (1)`. There is no special “RESP\_CODE\_OK” for sends – a distinction from some simpler protocols. And for receiving, the codes 7/8 (or 16/17 for v3 format) distinguish contact vs channel messages. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   **No extra init in payload:** Apart from ensuring the channel exists (discussed next), you do not need to include any “channel init” bytes *within* the CMD\_SEND\_CHANNEL\_TXT\_MSG. The command by itself is designed to both identify the channel and carry the message. (In other words, the payload format described above is complete; don’t try to prepend a channel name or length outside of what’s specified.)

## 4. **PugetMesh Compatibility and Configuration**

Your MeshCore device is configured for “PugetMesh” (910.525 MHz, BW 62.5 kHz, SF7, CR5). These settings define the **radio frequency and modulation parameters** for your mesh – effectively the physical channel. The good news is that **hashtag channel messaging works the same regardless of radio settings**. The `CMD_SEND_CHANNEL_TXT_MSG` protocol and payload do not change with frequency or bandwidth. So there are no special command-format considerations for PugetMesh versus any other frequency plan.

However, there are a few **operational considerations** to keep in mind:

*   **Network Channel vs. Hashtag Channel:** Ensure all devices that need to communicate are indeed on the *same LoRa network configuration*. MeshCore devices will only exchange messages if they share the same base radio channel (frequency, spreading factor, encryption keys, etc.). PugetMesh is one such configuration profile. As long as all your devices (or your device and your app) use PugetMesh settings, they can hear each other on the default mesh channel. If one device were on a different frequency or had a different network crypto key, it would be “invisible” to the others – no contacts discovered and no messages exchanged. In short, **PugetMesh vs others doesn’t affect how you form the command, but it does affect who receives it**. Make sure any target devices are running with the same regional settings and channel secrets as your sender. [\[MeshCore C...tem Techni | Word\]](https://microsoft-my.sharepoint.com/personal/wayneb_microsoft_com/_layouts/15/Doc.aspx?sourcedoc=%7BC8A9C280-FB5F-4DEB-BBCB-B505CE5693C2%7D\&file=MeshCore%20Contact%20System%20Techni.docx\&action=default\&mobileredirect=true\&DefaultItemOpen=1)

*   **Hashtag channels across configs:** The concept of hashtag channels (#bot, #general) is *logical* on top of the physical network. If all nodes share PugetMesh, a message on `#bot` will propagate to those nodes (and only those nodes) that have joined the `#bot` logical channel. If later you had a different network (say a different frequency or encryption group), they would have their own separate “#bot” potentially. But within a given mesh network, channels behave consistently. There’s no special frequency dependency – e.g., `#bot` doesn’t require a different SF or anything. It works the same on 910.525 MHz SF7 as it would on another frequency; only range/throughput are affected by those radio settings, not the protocol logic.

*   **Firmware version requirements:** Make sure your device’s firmware actually supports channel messaging. MeshCore’s group channel feature is supported in **protocol version 1 (and above)** – it is a core feature, not an optional add-on. Given that your device responds to advanced commands like `CMD_DEVICE_QUERY (0x16)` and `CMD_GET_CONTACTS (0x04)`, it’s likely running a modern firmware (v1.10+ or later) that does include `CMD_SEND_CHANNEL_TXT_MSG`. There is no separate “enable” for hashtag channels – if the command exists in the protocol and the feature isn’t disabled, it should just work. (If the firmware did not support it at all, you’d get an `ERR_CODE_UNSUPPORTED_CMD` instantly, but since you also suspect a misunderstanding rather than a missing feature, we proceed under the assumption the firmware is new enough and channel messaging is available.) There is a `RESP_CODE_DISABLED` (0x0F) in the protocol, but that would only come if the firmware deliberately turned off channel messaging; there’s no indication of that in standard devices. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   **PugetMesh summary:** In essence, treat PugetMesh as just the pipe. The hashtag messaging protocol rides on top of it unchanged. So you don’t need any special tweaks in your SDK for those settings beyond ensuring the device is configured and connected properly. As long as the device is in range and on the same network channel, a `CMD_SEND_CHANNEL_TXT_MSG` to a valid channel will broadcast to all nodes in that mesh (the physical link budget and spreading factor SF7 will determine how far it goes, but that’s a radio concern, not a protocol one).

*   **Channel keys (if any):** One potential PugetMesh-specific note: If PugetMesh uses a particular encryption or channel key, all devices must share it to participate in the same hashtag channel. Many MeshCore channels (including the default) might be unencrypted or use a known default AES key for “public” domain. If you configure a private channel (non-zero), you typically set a channel secret for it so that only authorized nodes get those messages. Ensure the channel secret (if your firmware/app asks for one when configuring #bot or others) is consistent across your devices. [\[MeshCore C...tem Techni | Word\]](https://microsoft-my.sharepoint.com/personal/wayneb_microsoft_com/_layouts/15/Doc.aspx?sourcedoc=%7BC8A9C280-FB5F-4DEB-BBCB-B505CE5693C2%7D\&file=MeshCore%20Contact%20System%20Techni.docx\&action=default\&mobileredirect=true\&DefaultItemOpen=1)

In summary, **no special protocol changes are needed for PugetMesh** – just ensure your devices are configured to hear each other, and the hashtag channel feature will operate normally on that frequency plan.

## 5. **Differences from Direct Messaging (CMD\_SEND\_TXT\_MSG)**

**Payload structure differences:** The direct message command (`CMD_SEND_TXT_MSG`, 0x02) and the channel message command (`CMD_SEND_CHANNEL_TXT_MSG`, 0x03) share a similar purpose (delivering a text message) but have different payload layouts:

*   In a **direct message**, after the command code (0x02) and text type, the payload includes a **retry attempt counter** and the **recipient’s address**. Specifically, `CMD_SEND_TXT_MSG` uses a 6-byte **public key prefix** to identify the target contact in your address book. For example, if the recipient’s full public key is stored in the device, you provide the first 6 bytes of that key (`pub_key_prefix`) to tell the firmware which contact to send to. This means you must have that contact in the device’s contact list. The payload then ends with the null-terminated message text. The structure (for reference) was:\
    `0x02 | txt_type | attempt# | timestamp | pubkey_prefix[6] | text...`. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   In a **channel message**, there is **no contact prefix** and no “attempt” field (since broadcasts aren’t retried in the same way). Instead, a one-byte **channel index** is used in that position. So the channel payload is:\
    `0x03 | txt_type | channel_idx | timestamp | text...`.
    The absence of the 6-byte address is why the channel command payload is so much shorter (7 bytes of overhead vs. 13 bytes for direct). The device doesn’t need an explicit recipient address because the message is automatically addressed to *all nodes listening on the given channel*. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   **No “attempt” byte:** The direct message format has an `attempt` field (0 for first try, 1 for retry, etc.) to support internal retry logic or indicating duplicate sends. The channel message format in the official spec does **not include** this field. In practice, the device will treat each channel send as a one-shot broadcast. If it fails (e.g., no ACK – but broadcasts don’t get ACKs), the mesh doesn’t automatically retry at the protocol level. It’s up to the application if it wants to attempt again. The omission of an attempt counter is deliberate, as flooding the same message multiple times is often handled differently (e.g., via flood relaying or higher-level logic, not simple retries). [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Response handling:** Both commands use the same mechanism for indicating success or failure of the send request: `RESP_CODE_SENT (6)` on success (queued) or `RESP_CODE_ERR (1)` on immediate failure. However, **the semantics of message delivery and acknowledgment differ:** [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   For a direct message, after `RESP_CODE_SENT`, the device expects an ACK from the specific recipient. If the recipient node receives the message, it will send back an ACK over the mesh, and your device will then emit a `PUSH_CODE_SEND_CONFIRMED` (0x82) to let the app know the message got through. If no ACK arrives within the timeout, the message might be marked as failed (and the device could optionally retry if attempt < max). Your SDK or app might show delivery status (e.g., delivered ✔✔ vs. pending) based on this. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   For a channel message, there is **no per-recipient acknowledgment**. The device sets `is_flood=1` in RESP\_CODE\_SENT, and no further ACK confirmation is expected (since **there may be multiple recipients** and no single ACK can confirm all of them). The message is just broadcast; individual recipients do not send ACKs for channel messages in the standard MeshCore design. So your app will usually treat a channel message as delivered *if it was transmitted*, with no “read” or “received” receipts. This is akin to a radio broadcast or UDP multicast – send and forget. (If reliability is a concern, the application layer would have to implement its own handshakes or simply rely on the fact that mesh flooding tries its best to reach everyone.) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

*   In summary: **direct messages have potential two-phase feedback** (sent → then confirmed), whereas **channel messages only have one immediate feedback** (sent queued). This is reflected in the `expected_ack` handling: for direct, the `expected_ack` token in RESP\_CODE\_SENT is meaningful, for channel it’s mostly a placeholder and likely not fulfilled by any ACK. [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol)

**Error codes:** Both command types can yield errors but the contexts differ:

*   A direct message can fail with `ERR_CODE_NOT_FOUND` if the 6-byte prefix doesn’t match any known contact (i.e. you tried to send to someone not in your contacts). It could also fail with `ERR_CODE_BAD_STATE` if, say, the device isn’t in a state to send (network down), or `ERR_CODE_ILLEGAL_ARG` if the timestamp is out of range (just theoretical examples). In your case, since direct messaging presumably works, these aren’t an issue. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   A channel message can fail with `ERR_CODE_NOT_FOUND` if the specified channel index doesn’t exist or isn’t configured on the device. It might also return `ERR_CODE_ILLEGAL_ARG` if, for example, you used a reserved or invalid channel number or an out-of-range value (though typically 0–9 are valid indices if configured). If the channel feature was disabled (not common), it could return `ERR_CODE_UNSUPPORTED_CMD` or `RESP_CODE_DISABLED`. The key differences: direct depends on having a contact entry; channel depends on having a channel entry. So the failure modes differ accordingly. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   In your trials, **“InvalidCommand”** likely corresponded to an `RESP_CODE_ERR` with `ERR_CODE_UNSUPPORTED_CMD (0x01)` – essentially the device saying *“I don’t understand this command format.”* This happens if the payload didn’t match what the firmware expects for `CMD_SEND_CHANNEL_TXT_MSG`. As discussed, providing a channel name string instead of an index would cause that, because the device would see unexpected bytes (e.g. ASCII 0x62 for 'b' where it expects a small channel number or a timestamp byte) and choke on it. Once you send the correct format (with the numeric ID), that particular error should go away. If you then get a different error like ERR\_CODE\_NOT\_FOUND, it means the format is right but the **channel isn’t set up** (next section).

**Receiving side differences:** When a message arrives, the firmware differentiates direct vs channel in the indication: it sends either `RESP_CODE_CONTACT_MSG_RECV` (0x07 or 0x10) for direct messages or `RESP_CODE_CHANNEL_MSG_RECV` (0x08 or 0x11) for channel messages. The channel message include a channel index so the app knows which channel it came on, whereas direct includes the sender’s ID. Your .NET SDK should handle these appropriately (e.g., raising a MessageReceived event with a property indicating channel vs direct). Just be aware in your implementation that channel messages won’t have a `Sender` contact in the usual sense; instead they might carry the sender’s ID and channel info separately. (From the Home Assistant logs you provided, it appears channel messages are logged with a prefix indicating the channel and the sender’s name – that is exactly the information the device provides: channel ID and sender.) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol) [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/messaging/), [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/messaging/)

## 6. **Alternative Approaches and Additional Commands**

**Is CMD\_SEND\_CHANNEL\_TXT\_MSG the correct command?** – Yes, **this is the correct and intended command for sending broadcast messages to a hashtag channel**. There isn’t a better or different “official” command for sending text to a group; 0x03 is the one defined in the MeshCore protocol. Given that, our goal is to use it correctly rather than find an entirely different command. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

However, there are a couple of related commands and points to consider:

*   **Channel configuration (`CMD_SET_CHANNEL`, 0x20):** One likely reason your attempts failed is that the channel wasn’t set up on the device. MeshCore requires that a channel beyond the default be configured in the device’s channel list. The command to do this is `CMD_SET_CHANNEL (0x20)`. This command allows you to **configure a new group channel** (with parameters like channel index, name, encryption key, etc.). For example, to use `#bot`, you might need to send a `CMD_SET_CHANNEL` defining channel ID 1 with the name “bot” and perhaps a security key (or mark it public). Once the device acknowledges that and adds the channel, you can then send messages to it. If you skip this step, the device doesn’t know what “channel 1” refers to – hence it returns an error when you try. Think of it as analogous to creating a chatroom before sending messages to it. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

    *In practical terms*, if you have an existing MeshCore mobile app or CLI, you would join/create `#bot` on the device through that interface, which under the hood uses CMD\_SET\_CHANNEL. In your custom .NET SDK, you’ll need to implement channel setup if you want to support channels beyond the default. The payload for CMD\_SET\_CHANNEL will include things like the channel ID (1 byte) and a structure for the channel (possibly a name string, a privilege flag, and an optional 256-bit AES key or short code). The exact format can be found in the MeshCore docs – but since your focus is sending, ensure at least that channel 1 exists. You can verify with `CMD_GET_CHANNEL (0x1F)` which returns details of a given channel (or `RESP_CODE_CHANNEL_INFO`). If you issue a get for channel 1 and get “not found”, you know you must configure it first. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   **Using direct messages as a fallback:** If, hypothetically, the firmware did not support CMD\_SEND\_CHANNEL\_TXT\_MSG (older device) or if you couldn’t get it working, one could emulate a “broadcast” by sending individual direct messages to each contact. For example, send “Hello” to Alice, Bob, Carol separately. **This is not efficient** (sends multiple LoRa transmissions) and lacks the atomic group semantics (each recipient gets it as a 1-to-1 message, not as a channel message). Thus, it’s generally not recommended except perhaps for a very small fixed group. The whole point of the channel feature is to avoid that manual fan-out.

*   **Other broadcast commands:** The MeshCore protocol has a `CMD_SEND_RAW_DATA (0x19)` which allows sending an arbitrary payload over the mesh, and a `CMD_SEND_CONTROL_DATA (0x37)` for control packets. These are low-level and intended for special use (telemetry, custom protocols). They are not meant to carry user text to a hashtag channel. The channel messaging (0x03) is already implemented to take care of packaging the text into the proper internal mesh packet (including the channel’s encryption, etc.). So you should stick with 0x03 for text. `CMD_SEND_TXT_MSG` (0x02) similarly should be used only for direct messages (it has logic for choosing unicast routes, etc.). [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

*   **No special addressing hack via 0x02:** You might wonder if you could use `CMD_SEND_TXT_MSG` with some special contact to simulate a channel (for instance, if there were a contact entry representing “all nodes”). MeshCore does not have an “all nodes” contact – instead it explicitly provided the channel mechanism. The contact list only holds individual nodes (each with a unique pubkey). The open broadcast domain is not a contact; it’s just channel 0. Therefore, using 0x02 for a group message isn’t possible unless you literally loop over contacts as above. There’s no magic pubkey prefix that means “everyone”. (If you used a wildcard like 0xFF... it would either not match anyone or collide with some actual key prefix – so that’s not a feature.)

*   **Ensure feature not disabled:** As a sanity check, the protocol defines `RESP_CODE_DISABLED (0x0F)` for cases where a feature is turned off at compile time. It’s rare, but if by any chance your device’s firmware did not support channels, it might return that. Since you got “InvalidCommand”, it was likely `ERR_CODE_UNSUPPORTED_CMD` under the hood (meaning the firmware didn’t parse it, possibly due to format). If it were truly not implemented, the device might have immediately returned ERR\_CODE\_UNSUPPORTED without even checking the rest of the frame. The distinction is subtle, but given the specs and that channels are a fundamental feature, we assume your device is supposed to handle it. All modern MeshCore companion firmware (v1.x) do support it. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

**Bottom line:** Use **CMD\_SEND\_CHANNEL\_TXT\_MSG (0x03)** with the correct format and setup. There isn’t a “different better command” for group chat – this is the one. Just make sure to **configure the channel** via `CMD_SET_CHANNEL` if needed, then send using the **numeric channel ID and proper payload structure** as described. Once you do that, your SDK’s calls should stop returning InvalidCommand and instead you’ll see the message go out with a `RESP_CODE_SENT` confirmation. The receiving devices (or the same device, if it loops back) will then deliver the message under the channel’s name as expected. [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)

**References:** The above conclusions are backed by the MeshCore protocol documentation and reference implementation. The command summary from MeshCore’s deepwiki confirms the payload structures and codes, and the GitHub wiki for the companion protocol provides field-by-field definitions (e.g., showing that channel messages use a channel index, not a name). The MeshCore device communication logs (Home Assistant example) also illustrate that channel messages are logged by channel ID, implying the name is not part of the transmitted frame. All of this aligns with the need to send the channel ID in the payload. By adjusting your implementation accordingly, you should be able to successfully send to `#bot`, `#general`, or any other configured hashtag channel on MeshCore. Good luck with MeshCore.Net.SDK v1.0 – once these pieces are in place, your channel messaging should work seamlessly! [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol) [\[meshcore-d....github.io\]](https://meshcore-dev.github.io/meshcore-ha/docs/ha/messaging/) [\[github.com\]](https://github.com/meshcore-dev/MeshCore/wiki/Companion-Radio-Protocol), [\[deepwiki.com\]](https://deepwiki.com/meshcore-dev/MeshCore/4.1.1-command-protocol)
